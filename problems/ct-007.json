{
  "id": "ct-007",
  "title": "大量データに対する部分集計クエリ",
  "difficulty": "hard",
  "category": ["segment-tree", "data-structure"],
  "time_limit_sec": 2.0,
  "memory_limit_mb": 512,
  "description": "# 大量データに対する部分集計クエリ\n\n## 問題概要\n\n整数の配列に対して、以下の操作を効率的に処理できるデータ構造を実装してください。\n\n1. `update(index, value)`: 配列の `index` 番目の要素を `value` に更新\n2. `query(left, right)`: 区間 `[left, right]` の連続する部分配列の和の最大値を取得（空でない部分配列）\n\n## 入力仕様\n\n- `initial_array`: 初期配列（整数のリスト）\n- `operations`: 操作のリスト。各操作は以下のいずれか\n  - `(\"update\", index, value)`: 更新操作\n  - `(\"query\", left, right)`: クエリ操作\n\n## 出力仕様\n\n- `list[int]`: 各クエリ操作に対する結果のリスト（順序はクエリの実行順）\n\n## 制約条件\n\n- `1 <= len(initial_array) <= 10^5`\n- `-10^4 <= initial_array[i] <= 10^4`\n- `1 <= len(operations) <= 10^5`\n- `0 <= index < len(initial_array)`\n- `0 <= left <= right < len(initial_array)`\n- `-10^4 <= value <= 10^4`\n\n## サンプル入力・出力\n\n### サンプル1（全正数）\n\n入力:\n```python\ninitial_array = [1, 2, 3, 4]\noperations = [(\"query\", 0, 3)]\n```\n\n出力:\n```python\n[10]  # [1,2,3,4]の和 = 10\n```\n\n### サンプル2（全負数）\n\n入力:\n```python\ninitial_array = [-5, -1, -3]\noperations = [(\"query\", 0, 2)]\n```\n\n出力:\n```python\n[-1]  # 最大部分和は-1（要素[-1]のみ）\n```\n\n### サンプル3（正負混在）\n\n入力:\n```python\ninitial_array = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\noperations = [(\"query\", 0, 8)]\n```\n\n出力:\n```python\n[6]  # [4, -1, 2, 1]の和 = 6\n```\n\n### サンプル4（更新あり）\n\n入力:\n```python\ninitial_array = [1, 2, 3]\noperations = [\n    (\"query\", 0, 2),\n    (\"update\", 1, -10),\n    (\"query\", 0, 2)\n]\n```\n\n出力:\n```python\n[6, 3]  # 最初は[1,2,3]=6、更新後は[1,-10,3]で最大部分和はmax(1,3,1+3)=3\n```",
  "function_signature": "def solve(initial_array: list[int], operations: list[tuple]) -> list[int]:",
  "test_code": "def test_sample1():\n    assert solve([1, 2, 3, 4], [(\"query\", 0, 3)]) == [10]\n\ndef test_sample2():\n    assert solve([-5, -1, -3], [(\"query\", 0, 2)]) == [-1]\n\ndef test_sample3():\n    result = solve([-2, 1, -3, 4, -1, 2, 1, -5, 4], [(\"query\", 0, 8)])\n    assert result[0] == 6\n\ndef test_sample4():\n    ops = [(\"query\", 0, 2), (\"update\", 1, -10), (\"query\", 0, 2)]\n    result = solve([1, 2, 3], ops)\n    assert len(result) == 2\n    assert result[0] == 6\n    assert result[1] >= 3  # 更新後の最大部分和\n\ndef test_single_element():\n    assert solve([5], [(\"query\", 0, 0)]) == [5]\n    assert solve([-5], [(\"query\", 0, 0)]) == [-5]\n\ndef test_all_positive():\n    assert solve([1, 2, 3], [(\"query\", 0, 2)]) == [6]\n\ndef test_all_negative():\n    result = solve([-1, -2, -3], [(\"query\", 0, 2)])\n    assert result[0] == -1  # 最大値は-1\n\ndef test_update_only():\n    ops = [(\"update\", 0, 10), (\"query\", 0, 0)]\n    assert solve([1], ops) == [10]\n\ndef test_multiple_queries():\n    ops = [(\"query\", 0, 1), (\"query\", 1, 2), (\"query\", 0, 2)]\n    result = solve([1, -2, 3], ops)\n    assert len(result) == 3\n    assert result[0] == 1  # [1] or [1,-2]の最大\n    assert result[1] == 3  # [3]\n    assert result[2] == 3  # [3] or [1,-2,3]の最大\n\ndef test_mixed_operations():\n    ops = [\n        (\"query\", 0, 2),\n        (\"update\", 1, 5),\n        (\"query\", 0, 2),\n        (\"update\", 0, -10),\n        (\"query\", 0, 2)\n    ]\n    result = solve([1, 2, 3], ops)\n    assert len(result) == 3"
}




