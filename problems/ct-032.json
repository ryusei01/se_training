{
  "id": "ct-032",
  "title": "構文木の評価",
  "difficulty": "hard",
  "category": [
    "tree",
    "recursion",
    "evaluation"
  ],
  "time_limit_sec": 2.0,
  "memory_limit_mb": 512,
  "description": "# 構文木の評価\n\n## 問題概要\n\n論理式を表す構文木が与えられます。変数の値が設定されているとき、式の評価結果を返してください。\n\n## 入力仕様\n\n- `root`: 構文木のルートノード。各ノードは以下のプロパティを持つ\n  - `type`: ノードタイプ（\"AND\", \"OR\", \"NOT\", \"VAR\" のいずれか）\n  - `children`: 子ノードのリスト（\"VAR\" の場合は空）\n  - `value`: 変数名（\"VAR\" の場合のみ存在）\n- `variables`: 変数の値の辞書。キーは変数名、値は `True` または `False`\n\n## 出力仕様\n\n- `bool`: 式の評価結果\n\n## 制約条件\n\n- ノード数は 1 以上 1000 以下\n- 構文木は正しい形式\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```\n構文木:\nAND\n  OR\n    A\n    B\n  NOT\n    C\n\nvariables = {\"A\": True, \"B\": False, \"C\": True}\n```\n\n出力:\n```python\nFalse  # AND(OR(True, False), NOT(True)) = AND(True, False) = False\n```",
  "function_signature": "def solve(root: dict, variables: dict[str, bool]) -> bool:",
  "test_code": "def test_sample1():\n    root = {\n        \"type\": \"AND\",\n        \"children\": [\n            {\"type\": \"OR\", \"children\": [{\"type\": \"VAR\", \"value\": \"A\"}, {\"type\": \"VAR\", \"value\": \"B\"}]},\n            {\"type\": \"NOT\", \"children\": [{\"type\": \"VAR\", \"value\": \"C\"}]}\n        ]\n    }\n    variables = {\"A\": True, \"B\": False, \"C\": True}\n    result = solve(root, variables)\n    # AND(OR(True, False), NOT(True)) = AND(True, False) = False\n    assert result == False\n\ndef test_single_var():\n    root = {\"type\": \"VAR\", \"value\": \"A\"}\n    variables = {\"A\": True}\n    assert solve(root, variables) == True\n\ndef test_not():\n    root = {\"type\": \"NOT\", \"children\": [{\"type\": \"VAR\", \"value\": \"A\"}]}\n    variables = {\"A\": True}\n    assert solve(root, variables) == False",
  "supported_languages": [
    "python",
    "typescript"
  ],
  "hint": "## ヒント\n\n- 構文木を再帰的に評価します\n- `AND` ノード: すべての子ノードが `True` なら `True`\n- `OR` ノード: いずれかの子ノードが `True` なら `True`\n- `NOT` ノード: 子ノードの結果を反転\n- `VAR` ノード: 変数辞書から値を取得\n- 葉ノード（VAR）から順に評価していきます",
  "solution": "## 答えと解説\n\nこの問題は、論理式を表す構文木を評価する問題です。\n\n### アプローチ\n\n構文木を再帰的に評価します。各ノードタイプに応じて、適切な論理演算を実行します。\n\n### 実装コード\n\n```python\ndef solve(root: dict, variables: dict[str, bool]) -> bool:\n    def evaluate(node):\n        if node is None:\n            return False\n        \n        node_type = node[\"type\"]\n        \n        if node_type == \"VAR\":\n            # 変数ノード: 変数辞書から値を取得\n            var_name = node[\"value\"]\n            return variables.get(var_name, False)\n        \n        elif node_type == \"NOT\":\n            # NOTノード: 子ノードの結果を反転\n            children = node.get(\"children\", [])\n            if not children:\n                return False\n            return not evaluate(children[0])\n        \n        elif node_type == \"AND\":\n            # ANDノード: すべての子ノードが True なら True\n            children = node.get(\"children\", [])\n            if not children:\n                return True\n            return all(evaluate(child) for child in children)\n        \n        elif node_type == \"OR\":\n            # ORノード: いずれかの子ノードが True なら True\n            children = node.get(\"children\", [])\n            if not children:\n                return False\n            return any(evaluate(child) for child in children)\n        \n        return False\n    \n    return evaluate(root)\n```\n\n```typescript\nexport function solve(root: dict, variables: dict[str, bool]) : boolean {\n    def evaluate(node):\n        if node is null:\n            return false\n        \n        node_type = node[\"type\"]\n        \n        if node_type == \"VAR\":\n            # 変数ノード: 変数辞書から値を取得\n            var_name = node[\"value\"]\n            return variables.get(var_name, false)\n        \n        elif node_type == \"NOT\":\n            # NOTノード: 子ノードの結果を反転\n            children = node.get(\"children\", [])\n            if not children:\n                return false\n            return not evaluate(children[0])\n        \n        elif node_type == \"AND\":\n            # ANDノード: すべての子ノードが true なら true\n            children = node.get(\"children\", [])\n            if not children:\n                return true\n            return all(evaluate(child) for child in children)\n        \n        elif node_type == \"OR\":\n            # ORノード: いずれかの子ノードが true なら true\n            children = node.get(\"children\", [])\n            if not children:\n                return false\n            return any(evaluate(child) for child in children)\n        \n        return false\n    \n    return evaluate(root)\n```\n\n### 動作例\n\nサンプル1の場合：\n```\n構文木:\nAND\n  OR\n    A\n    B\n  NOT\n    C\n\nvariables = {\"A\": True, \"B\": False, \"C\": True}\n```\n\n- `OR(A, B)` → `OR(True, False)` → `True`\n- `NOT(C)` → `NOT(True)` → `False`\n- `AND(True, False)` → `False`\n\n結果: `False`\n\n### 時間計算量\n\n- O(N): Nはノード数。各ノードを1回ずつ訪問します。\n\n### 空間計算量\n\n- O(H): Hは木の高さ。再帰のスタックが高さ分必要です。"
}