{
  "id": "ct-022",
  "title": "重み付き経路スコアの最大値",
  "difficulty": "hard",
  "category": [
    "tree",
    "dfs",
    "recursion"
  ],
  "time_limit_sec": 2.0,
  "memory_limit_mb": 512,
  "description": "# 重み付き経路スコアの最大値\n\n## 問題概要\n\nルートから葉まで進むとき、次のルールでスコアを定義します。\n\n- 最初のスコアはルート値\n- 左へ進むたびに「現在スコアを2倍して子の値を足す」\n- 右へ進むたびに「現在スコアを3倍して子の値を足す」\n\nこのとき、全経路のスコアのうち最大値を求めてください。\n\n## 入力仕様\n\n- `root`: 二分木のルートノード。各ノードは以下のプロパティを持つ\n  - `val`: ノードの値（整数）\n  - `left`: 左の子ノード（ノードまたは `null`）\n  - `right`: 右の子ノード（ノードまたは `null`）\n\n## 出力仕様\n\n- `int`: すべての経路のスコアの最大値\n\n## 制約条件\n\n- ノード数は 1 以上 1000 以下\n- `-10^4 <= val <= 10^4`\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```\n        2\n      /   \\\n     1     3\n    / \\   / \\\n   2   0 1   4\n```\n\n出力:\n```\n29  # 経路1: 2 → 左(2*2+1=5) → 左(5*2+2=12) → スコア=12\n    # 経路2: 2 → 左(2*2+1=5) → 右(5*3+0=15) → スコア=15\n    # 経路3: 2 → 右(2*3+3=9) → 左(9*2+1=19) → スコア=19\n    # 経路4: 2 → 右(2*3+3=9) → 右(9*3+4=31) → スコア=31\n    # 最大: 31\n```\n\n注: 実際の計算では最大スコアは31",
  "function_signature": "def solve(root) -> int:",
  "test_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef test_sample1():\n    #        2\n    #      /   \\\n    #     1     3\n    #    / \\   / \\\n    #   2   0 1   4\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(0)\n    root.right.left = TreeNode(1)\n    root.right.right = TreeNode(4)\n    result = solve(root)\n    # 経路1: 2 → 左(2*2+1=5) → 左(5*2+2=12) → 12\n    # 経路2: 2 → 左(2*2+1=5) → 右(5*3+0=15) → 15\n    # 経路3: 2 → 右(2*3+3=9) → 左(9*2+1=19) → 19\n    # 経路4: 2 → 右(2*3+3=9) → 右(9*3+4=31) → 31\n    # 最大: 31\n    assert result == 31\n\ndef test_single_node():\n    root = TreeNode(5)\n    assert solve(root) == 5\n\ndef test_two_levels():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    # 経路1: 1 → 左(1*2+2=4) → 4\n    # 経路2: 1 → 右(1*3+3=6) → 6\n    # 最大: 6\n    assert solve(root) == 6",
  "supported_languages": [
    "python",
    "typescript"
  ],
  "hint": "## ヒント\n\n- 左に進むとスコアを2倍、右に進むと3倍する特殊なルールがあります\n- DFSを使って、各経路のスコアを計算します\n- 現在のスコアを引数として渡し、左に進む場合は2倍、右に進む場合は3倍します\n- 葉ノードに到達したら、その時点でのスコアを返します\n- 内部ノードでは、左右の子ノードから返ってきた値の最大値を返します",
  "solution": "## 答えと解説\n\nこの問題は、ルートから葉までの経路について、特殊な重み付けルールでスコアを計算し、最大値を求める問題です。\n\n### アプローチ\n\nDFS（深さ優先探索）を使って、ルートから葉までの全経路を探索します。各経路について、左に進む場合はスコアを2倍、右に進む場合は3倍して、子ノードの値を足します。\n\n### 実装コード\n\n```python\ndef solve(root) -> int:\n    def dfs(node, current_score):\n        if node is None:\n            return float('-inf')\n        \n        # 現在のスコアを更新（ルートの場合は初期値、それ以外は親から継承）\n        if current_score == 0:\n            new_score = node.val\n        else:\n            # この部分は実際には親ノードから方向情報が必要\n            # より実装しやすい方法: 親から方向情報を渡す\n            pass\n    \n    # より実装しやすい方法: 親ノードと方向情報を引数として渡す\n    def dfs_with_parent(node, parent_score, is_left):\n        if node is None:\n            return float('-inf')\n        \n        # スコアを計算\n        if is_left:\n            new_score = parent_score * 2 + node.val\n        else:\n            new_score = parent_score * 3 + node.val\n        \n        # 葉ノードの場合、現在のスコアを返す\n        if node.left is None and node.right is None:\n            return new_score\n        \n        # 左右の子ノードから返ってきた値の最大値を返す\n        left_max = dfs_with_parent(node.left, new_score, True) if node.left else float('-inf')\n        right_max = dfs_with_parent(node.right, new_score, False) if node.right else float('-inf')\n        return max(left_max, right_max)\n    \n    # ルートノードの処理\n    if root is None:\n        return float('-inf')\n    \n    root_score = root.val\n    if root.left is None and root.right is None:\n        return root_score\n    \n    left_max = dfs_with_parent(root.left, root_score, True) if root.left else float('-inf')\n    right_max = dfs_with_parent(root.right, root_score, False) if root.right else float('-inf')\n    return max(left_max, right_max)\n```\n\n```typescript\nexport function solve(root) : number {\n    def dfs(node, current_score):\n        if node is null:\n            return float('-inf')\n        \n        # 現在のスコアを更新（ルートの場合は初期値、それ以外は親から継承）\n        if current_score == 0:\n            new_score = node.val\n        else:\n            # この部分は実際には親ノードから方向情報が必要\n            # より実装しやすい方法: 親から方向情報を渡す\n            pass\n    \n    # より実装しやすい方法: 親ノードと方向情報を引数として渡す\n    def dfs_with_parent(node, parent_score, is_left):\n        if node is null:\n            return float('-inf')\n        \n        # スコアを計算\n        if is_left:\n            new_score = parent_score * 2 + node.val\n        else:\n            new_score = parent_score * 3 + node.val\n        \n        # 葉ノードの場合、現在のスコアを返す\n        if node.left is null and node.right is null:\n            return new_score\n        \n        # 左右の子ノードから返ってきた値の最大値を返す\n        left_max = dfs_with_parent(node.left, new_score, true) if node.left else float('-inf')\n        right_max = dfs_with_parent(node.right, new_score, false) if node.right else float('-inf')\n        return max(left_max, right_max)\n    \n    # ルートノードの処理\n    if root is null:\n        return float('-inf')\n    \n    root_score = root.val\n    if root.left is null and root.right is null:\n        return root_score\n    \n    left_max = dfs_with_parent(root.left, root_score, true) if root.left else float('-inf')\n    right_max = dfs_with_parent(root.right, root_score, false) if root.right else float('-inf')\n    return max(left_max, right_max)\n```\n\n### 動作例\n\nサンプル1の場合：\n```\n        2\n      /   \\\n     1     3\n    / \\   / \\\n   2   0 1   4\n```\n\n- 経路1: 2 → 左(2*2+1=5) → 左(5*2+2=12) → スコア=12\n- 経路2: 2 → 左(2*2+1=5) → 右(5*3+0=15) → スコア=15\n- 経路3: 2 → 右(2*3+3=9) → 左(9*2+1=19) → スコア=19\n- 経路4: 2 → 右(2*3+3=9) → 右(9*3+4=31) → スコア=31（最大）\n- 最大値: 31\n\n### 時間計算量\n\n- O(N): Nはノード数。各ノードを1回ずつ訪問します。\n\n### 空間計算量\n\n- O(H): Hは木の高さ。再帰のスタックが高さ分必要です。"
}