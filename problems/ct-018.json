{
  "id": "ct-018",
  "title": "最大経路和",
  "difficulty": "medium",
  "category": ["tree", "dynamic-programming", "dfs"],
  "time_limit_sec": 1.0,
  "memory_limit_mb": 256,
  "description": "# 最大経路和\n\n## 問題概要\n\n数値ツリーが与えられます。ルートから葉までの経路のうち、合計が最大となる経路の合計値を求めてください。\n\n## 入力仕様\n\n- `root`: 二分木のルートノード。各ノードは以下のプロパティを持つ\n  - `val`: ノードの値（整数）\n  - `left`: 左の子ノード（ノードまたは `null`）\n  - `right`: 右の子ノード（ノードまたは `null`）\n\n## 出力仕様\n\n- `int`: ルートから葉までの経路の最大合計値\n\n## 制約条件\n\n- ノード数は 1 以上 1000 以下\n- `-10^4 <= val <= 10^4`\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```\n        5\n      /   \\\n     9     6\n    / \\   / \\\n   4  10 2   7\n```\n\n出力:\n```\n28  # 経路 5→9→10 = 5+9+10 = 24 または 5→6→7 = 5+6+7 = 18\n    # 最大は 5→9→10 = 24\n```\n\n注: 実際の計算では最大経路は 5→9→10 = 24",
  "function_signature": "def solve(root) -> int:",
  "test_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef test_sample1():\n    #        5\n    #      /   \\\n    #     9     6\n    #    / \\   / \\\n    #   4  10 2   7\n    root = TreeNode(5)\n    root.left = TreeNode(9)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(10)\n    root.right.left = TreeNode(2)\n    root.right.right = TreeNode(7)\n    result = solve(root)\n    # 経路: 5+9+4=18, 5+9+10=24, 5+6+2=13, 5+6+7=18\n    # 最大: 24\n    assert result == 24\n\ndef test_single_node():\n    root = TreeNode(5)\n    assert solve(root) == 5\n\ndef test_negative_values():\n    root = TreeNode(-1)\n    root.left = TreeNode(-2)\n    root.right = TreeNode(-3)\n    # 最大: -1 + (-2) = -3 または -1 + (-3) = -4\n    result = solve(root)\n    assert result == -3 or result == -4",
  "supported_languages": ["python", "typescript"],
  "hint": "## ヒント\n\n- ルートから葉までの全経路を探索し、最大の合計値を求めます\n- DFSを使って各経路の合計を計算し、最大値を追跡します\n- 葉ノードに到達したら、その時点での合計値を返します\n- 内部ノードでは、左右の子ノードから返ってきた値の最大値を返します\n- 再帰関数で、現在のノードの値と累積合計を引数として渡します",
  "solution": "## 答えと解説\n\nこの問題は、二分木のルートから葉までの経路のうち、合計が最大となる経路の合計値を求める問題です。\n\n### アプローチ\n\nDFS（深さ優先探索）を使って、ルートから葉までの全経路を探索します。各経路について、経路上の値の合計を計算し、最大値を返します。\n\n### 実装コード\n\n```python\ndef solve(root) -> int:\n    def dfs(node, current_sum):\n        if node is None:\n            return float('-inf')\n        \n        # 現在のノードの値を累積合計に加える\n        new_sum = current_sum + node.val\n        \n        # 葉ノードの場合、現在の合計を返す\n        if node.left is None and node.right is None:\n            return new_sum\n        \n        # 左右の子ノードから返ってきた値の最大値を返す\n        return max(dfs(node.left, new_sum), dfs(node.right, new_sum))\n    \n    return dfs(root, 0)\n```\n\n### 動作例\n\nサンプル1の場合：\n```\n        5\n      /   \\\n     9     6\n    / \\   / \\\n   4  10 2   7\n```\n\n- 経路1: 5→9→4 → 合計=18\n- 経路2: 5→9→10 → 合計=24（最大）\n- 経路3: 5→6→2 → 合計=13\n- 経路4: 5→6→7 → 合計=18\n- 最大値: 24\n\n### 時間計算量\n\n- O(N): Nはノード数。各ノードを1回ずつ訪問します。\n\n### 空間計算量\n\n- O(H): Hは木の高さ。再帰のスタックが高さ分必要です。"
}


