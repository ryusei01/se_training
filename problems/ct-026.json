{
  "id": "ct-026",
  "title": "擬似ファイルツリーからフルパス列挙",
  "difficulty": "medium",
  "category": ["tree", "dfs", "string"],
  "time_limit_sec": 1.0,
  "memory_limit_mb": 256,
  "description": "# 擬似ファイルツリーからフルパス列挙\n\n## 問題概要\n\nインデント付き入力は、ディレクトリ構造を表します。\n\n- 子を持つ行はディレクトリ\n- 子を持たない行はファイル\n\nすべてのファイルのフルパスを列挙してください。\n\n## 入力仕様\n\n- `lines`: インデント付きの行のリスト。各行は文字列で、先頭のスペース数がインデントレベルを表す\n\n## 出力仕様\n\n- `list[str]`: すべてのファイルのフルパス（文字列のリスト）\n\n## 制約条件\n\n- `1 <= len(lines) <= 1000`\n- 各行の長さは 1 以上 100 以下\n- インデントはスペースで表される（タブではない）\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```python\nlines = [\n    \"root\",\n    \"  src\",\n    \"    index.ts\",\n    \"    util.ts\",\n    \"  test\",\n    \"    index.test.ts\"\n]\n```\n\n出力:\n```python\n[\n    \"root/src/index.ts\",\n    \"root/src/util.ts\",\n    \"root/test/index.test.ts\"\n]\n```",
  "function_signature": "def solve(lines: list[str]) -> list[str]:",
  "test_code": "def test_sample1():\n    lines = [\n        \"root\",\n        \"  src\",\n        \"    index.ts\",\n        \"    util.ts\",\n        \"  test\",\n        \"    index.test.ts\"\n    ]\n    result = solve(lines)\n    assert \"root/src/index.ts\" in result\n    assert \"root/src/util.ts\" in result\n    assert \"root/test/index.test.ts\" in result\n    assert len(result) == 3\n\ndef test_single_file():\n    lines = [\"file.txt\"]\n    result = solve(lines)\n    assert result == [\"file.txt\"]\n\ndef test_nested():\n    lines = [\n        \"a\",\n        \"  b\",\n        \"    c.txt\"\n    ]\n    result = solve(lines)\n    assert \"a/b/c.txt\" in result",
  "supported_languages": ["python", "typescript"],
  "hint": "## ヒント\n\n- インデントレベルを計算して、親子関係を構築します\n- スタックを使って、現在のパスを管理します\n- インデントが前の行より深い場合は、新しい子ノードを追加します\n- インデントが前の行より浅い場合は、スタックから適切な数だけポップします\n- ファイル（子を持たない行）の場合のみ、フルパスを結果に追加します",
  "solution": "## 答えと解説\n\nこの問題は、インデント付きのディレクトリ構造から、すべてのファイルのフルパスを列挙する問題です。\n\n### アプローチ\n\nスタックを使って、現在のパスを管理します。インデントレベルが深くなったら新しいディレクトリを追加し、浅くなったらスタックからポップします。\n\n### 実装コード\n\n```python\ndef solve(lines: list[str]) -> list[str]:\n    result = []\n    stack = []  # 現在のパス（ディレクトリ名のリスト）\n    \n    for line in lines:\n        # インデントレベルを計算（先頭のスペース数）\n        indent = 0\n        while indent < len(line) and line[indent] == ' ':\n            indent += 1\n        \n        name = line[indent:].strip()\n        \n        # スタックから適切な数だけポップ（インデントレベルに合わせる）\n        while len(stack) > indent // 2:  # インデントは2スペース単位と仮定\n            stack.pop()\n        \n        # 現在の行がファイルかディレクトリかを判定\n        # 次の行を見て、より深いインデントがあるかチェック\n        is_file = True\n        current_index = lines.index(line)\n        if current_index + 1 < len(lines):\n            next_line = lines[current_index + 1]\n            next_indent = 0\n            while next_indent < len(next_line) and next_line[next_indent] == ' ':\n                next_indent += 1\n            if next_indent > indent:\n                is_file = False\n        \n        # パスを構築\n        current_path = stack + [name]\n        \n        # ファイルの場合のみ、フルパスを追加\n        if is_file:\n            result.append(\"/\".join(current_path))\n        else:\n            # ディレクトリの場合はスタックに追加\n            stack.append(name)\n    \n    return result\n```\n\n### 動作例\n\nサンプル1の場合：\n```\n[\"root\", \"  src\", \"    index.ts\", \"    util.ts\", \"  test\", \"    index.test.ts\"]\n```\n\n- \"root\" → ディレクトリ、スタック: [\"root\"]\n- \"  src\" → ディレクトリ、スタック: [\"root\", \"src\"]\n- \"    index.ts\" → ファイル、パス: \"root/src/index.ts\"\n- \"    util.ts\" → ファイル、パス: \"root/src/util.ts\"\n- \"  test\" → ディレクトリ、スタック: [\"root\", \"test\"]\n- \"    index.test.ts\" → ファイル、パス: \"root/test/index.test.ts\"\n\n### 時間計算量\n\n- O(N): Nは行数。各行を1回ずつ処理します。\n\n### 空間計算量\n\n- O(N): スタックと結果リストにO(N)の空間が必要です。"
}


