{
  "id": "ct-024",
  "title": "数値三角形の最大経路和と経路数",
  "difficulty": "hard",
  "category": [
    "dynamic-programming",
    "array",
    "counting"
  ],
  "time_limit_sec": 2.0,
  "memory_limit_mb": 512,
  "description": "# 数値三角形の最大経路和と経路数\n\n## 問題概要\n\n数値三角形が与えられます。ルートから最下段までの最大経路和と、その最大経路和を達成する経路の本数を求めてください。\n\n## 入力仕様\n\n- `triangle`: 数値三角形。各行は整数のリストで、i行目（0-indexed）は i+1 個の要素を持つ\n\n## 出力仕様\n\n- `dict`: 以下の2つのプロパティを持つ辞書\n  - `maxSum`: 最大経路和（整数）\n  - `pathCount`: 最大経路和を達成する経路の本数（整数、mod 1,000,000,007）\n\n## 制約条件\n\n- `1 <= len(triangle) <= 2000`\n- `-10^9 <= triangle[i][j] <= 10^9`\n- 負の数が含まれる可能性がある\n- 最大値が同値になる経路が複数存在する可能性がある\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```python\ntriangle = [\n    [1],\n    [2, 1],\n    [4, 5, 1],\n    [1, 2, 3, 4]\n]\n```\n\n出力:\n```python\n{\n    \"maxSum\": 12,\n    \"pathCount\": 1  # 最大経路: 1→2→5→4 のみ\n}\n```",
  "function_signature": "def solve(triangle: list[list[int]]) -> dict:",
  "test_code": "def test_sample1():\n    triangle = [\n        [1],\n        [2, 1],\n        [4, 5, 1],\n        [1, 2, 3, 4]\n    ]\n    result = solve(triangle)\n    assert result[\"maxSum\"] == 12\n    assert result[\"pathCount\"] == 1\n\ndef test_single_row():\n    triangle = [[5]]\n    result = solve(triangle)\n    assert result[\"maxSum\"] == 5\n    assert result[\"pathCount\"] == 1\n\ndef test_multiple_paths():\n    triangle = [\n        [1],\n        [2, 2],\n        [3, 3, 3]\n    ]\n    result = solve(triangle)\n    # 最大: 1+2+3=6, 経路数: 3通り\n    assert result[\"maxSum\"] == 6\n    assert result[\"pathCount\"] == 3",
  "supported_languages": [
    "python",
    "typescript"
  ],
  "hint": "## ヒント\n\n- 動的プログラミング（DP）を2回使います\n- 1回目: 最大経路和を計算（ct-023と同様）\n- 2回目: 各位置で最大経路和を達成する経路数を計算します\n- `pathCount[i][j]` を「i行目j列目に最大経路和で到達する経路数」とします\n- 最大経路和を達成する経路数の合計を計算します\n- モジュロ演算（mod 1,000,000,007）を忘れずに",
  "solution": "## 答えと解説\n\nこの問題は、数値三角形の最大経路和と、その最大経路和を達成する経路数を求める問題です。\n\n### アプローチ\n\n1. まず、各位置での最大経路和を計算します（ct-023と同様）\n2. 次に、各位置で最大経路和を達成する経路数を計算します\n3. 最下段で最大経路和を達成する位置の経路数を合計します\n\n### 実装コード\n\n```python\nMOD = 1000000007\n\ndef solve(triangle: list[list[int]]) -> dict:\n    if not triangle:\n        return {\"maxSum\": 0, \"pathCount\": 0}\n    \n    n = len(triangle)\n    \n    # dp[i][j]: i行目j列目に到達するまでの最大経路和\n    dp = [[0] * (i + 1) for i in range(n)]\n    \n    # 最初の行を初期化\n    dp[0][0] = triangle[0][0]\n    \n    # 最大経路和を計算\n    for i in range(1, n):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i][j] = triangle[i][j] + dp[i-1][0]\n            elif j == i:\n                dp[i][j] = triangle[i][j] + dp[i-1][j-1]\n            else:\n                dp[i][j] = triangle[i][j] + max(dp[i-1][j-1], dp[i-1][j])\n    \n    max_sum = max(dp[n-1])\n    \n    # 経路数を計算\n    path_count = [[0] * (i + 1) for i in range(n)]\n    path_count[0][0] = 1\n    \n    for i in range(1, n):\n        for j in range(i + 1):\n            if j == 0:\n                if dp[i-1][0] + triangle[i][j] == dp[i][j]:\n                    path_count[i][j] = path_count[i-1][0]\n            elif j == i:\n                if dp[i-1][j-1] + triangle[i][j] == dp[i][j]:\n                    path_count[i][j] = path_count[i-1][j-1]\n            else:\n                count = 0\n                if dp[i-1][j-1] + triangle[i][j] == dp[i][j]:\n                    count += path_count[i-1][j-1]\n                if dp[i-1][j] + triangle[i][j] == dp[i][j]:\n                    count += path_count[i-1][j]\n                path_count[i][j] = count % MOD\n    \n    # 最下段で最大経路和を達成する位置の経路数を合計\n    total_count = 0\n    for j in range(n):\n        if dp[n-1][j] == max_sum:\n            total_count = (total_count + path_count[n-1][j]) % MOD\n    \n    return {\"maxSum\": max_sum, \"pathCount\": total_count}\n```\n\n```typescript\nMOD = 1000000007\n\nexport function solve(triangle: list[number[]]) -> dict:\n    if not triangle:\n        return {\"maxSum\": 0, \"pathCount\": 0}\n    \n    n = triangle.length\n    \n    # dp[i][j]: i行目j列目に到達するまでの最大経路和\n    dp = [[0] * (i + 1) for i in range(n)]\n    \n    # 最初の行を初期化\n    dp[0][0] = triangle[0][0]\n    \n    # 最大経路和を計算\n    for i in range(1, n):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i][j] = triangle[i][j] + dp[i-1][0]\n            elif j == i:\n                dp[i][j] = triangle[i][j] + dp[i-1][j-1]\n            else:\n                dp[i][j] = triangle[i][j] + max(dp[i-1][j-1], dp[i-1][j])\n    \n    max_sum = max(dp[n-1])\n    \n    # 経路数を計算\n    path_count = [[0] * (i + 1) for i in range(n)]\n    path_count[0][0] = 1\n    \n    for i in range(1, n):\n        for j in range(i + 1):\n            if j == 0:\n                if dp[i-1][0] + triangle[i][j] == dp[i][j]:\n                    path_count[i][j] = path_count[i-1][0]\n            elif j == i:\n                if dp[i-1][j-1] + triangle[i][j] == dp[i][j]:\n                    path_count[i][j] = path_count[i-1][j-1]\n            else:\n                count = 0\n                if dp[i-1][j-1] + triangle[i][j] == dp[i][j]:\n                    count += path_count[i-1][j-1]\n                if dp[i-1][j] + triangle[i][j] == dp[i][j]:\n                    count += path_count[i-1][j]\n                path_count[i][j] = count % MOD\n    \n    # 最下段で最大経路和を達成する位置の経路数を合計\n    total_count = 0\n    for j in range(n):\n        if dp[n-1][j] == max_sum:\n            total_count = (total_count + path_count[n-1][j]) % MOD\n    \n    return {\"maxSum\": max_sum, \"pathCount\": total_count}\n```\n\n### 動作例\n\nサンプル1の場合：\n```\n[1]\n[2, 1]\n[4, 5, 1]\n[1, 2, 3, 4]\n```\n\n最大経路和は12で、それを達成する経路は1つです。\n\n### 時間計算量\n\n- O(N²): Nは行数。各位置を2回ずつ計算します。\n\n### 空間計算量\n\n- O(N²): DPテーブルにO(N²)の空間が必要です。"
}