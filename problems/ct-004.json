{
  "id": "ct-004",
  "title": "ログからAPI障害区間を特定せよ",
  "difficulty": "hard",
  "category": ["sliding-window", "array", "interval"],
  "time_limit_sec": 2.0,
  "memory_limit_mb": 512,
  "description": "# ログからAPI障害区間を特定せよ\n\n## 問題概要\n\nAPIのログが時系列で与えられます。各ログにはタイムスタンプとステータスコードが含まれています。スライディングウィンドウ方式で、一定時間内のエラー率が閾値を超えた区間を特定してください。\n\nエラー率 = (ステータスコード >= 500 のリクエスト数) / (ウィンドウ内の総リクエスト数)\n\nエラー率が閾値を**超えた**（等しくない）区間を障害区間とし、重複・隣接する区間はマージしてください。\n\n## 入力仕様\n\n- `logs`: ログのリスト。各要素は `(timestamp, status_code)` のタプル\n  - `timestamp`: タイムスタンプ（秒、整数）\n  - `status_code`: HTTPステータスコード（整数）\n- `window_sec`: スライディングウィンドウのサイズ（秒、正の整数）\n- `error_threshold`: エラー率の閾値（0.0 < error_threshold <= 1.0、浮動小数点数）\n\n## 出力仕様\n\n- `list[tuple[int, int]]`: 障害区間のリスト。各要素は `(start_time, end_time)` のタプルで、開始時刻と終了時刻を表す（両端含む）。区間は開始時刻の昇順でソートされ、重複・隣接区間はマージされている\n\n## 制約条件\n\n- `0 <= len(logs) <= 2 * 10^5`\n- `1 <= window_sec <= 10^6`\n- `0.0 < error_threshold <= 1.0`\n- ログはタイムスタンプの昇順でソートされている\n- `0 <= timestamp <= 10^9`\n- `100 <= status_code <= 599`\n\n## サンプル入力・出力\n\n### サンプル1（ログなし）\n\n入力:\n```python\nlogs = []\nwindow_sec = 60\nerror_threshold = 0.5\n```\n\n出力:\n```python\n[]\n```\n\n### サンプル2（常に正常）\n\n入力:\n```python\nlogs = [(0, 200), (10, 201), (20, 404), (30, 200)]\nwindow_sec = 60\nerror_threshold = 0.5\n```\n\n出力:\n```python\n[]  # すべてステータスコード < 500\n```\n\n### サンプル3（単一障害区間）\n\n入力:\n```python\nlogs = [(0, 200), (10, 500), (20, 500), (30, 200)]\nwindow_sec = 60\nerror_threshold = 0.5\n```\n\n出力:\n```python\n[(0, 60)]  # ウィンドウ[0,60]でエラー率2/4=0.5を超える（タイムスタンプ30まで含む）\n```\n\n### サンプル4（複数区間）\n\n入力:\n```python\nlogs = [(0, 500), (10, 500), (20, 200), (100, 500), (110, 500)]\nwindow_sec = 50\nerror_threshold = 0.5\n```\n\n出力:\n```python\n[(0, 50), (100, 150)]  # 2つの独立した障害区間\n```",
  "function_signature": "def solve(logs: list[tuple[int, int]], window_sec: int, error_threshold: float) -> list[tuple[int, int]]:",
  "test_code": "def test_sample1():\n    assert solve([], 60, 0.5) == []\n\ndef test_sample2():\n    logs = [(0, 200), (10, 201), (20, 404), (30, 200)]\n    assert solve(logs, 60, 0.5) == []\n\ndef test_sample3():\n    logs = [(0, 200), (10, 500), (20, 500), (30, 200)]\n    result = solve(logs, 60, 0.5)\n    assert len(result) == 1\n    assert result[0][0] == 0\n    assert result[0][1] >= 30\n\ndef test_sample4():\n    logs = [(0, 500), (10, 500), (20, 200), (100, 500), (110, 500)]\n    result = solve(logs, 50, 0.5)\n    assert len(result) >= 1\n    # 区間はソートされている\n    for i in range(len(result) - 1):\n        assert result[i][0] < result[i + 1][0]\n\ndef test_no_errors():\n    logs = [(0, 200), (10, 201), (20, 404)]\n    assert solve(logs, 60, 0.5) == []\n\ndef test_all_errors():\n    logs = [(0, 500), (10, 503), (20, 502)]\n    result = solve(logs, 60, 0.5)\n    assert len(result) == 1\n    assert result[0][0] <= 0\n    assert result[0][1] >= 20\n\ndef test_threshold_exact():\n    # エラー率がちょうど閾値の場合は含まない（超えた場合のみ）\n    logs = [(0, 500), (10, 200)]  # エラー率 = 0.5\n    result = solve(logs, 60, 0.5)\n    # 閾値を超えていないので空\n    assert isinstance(result, list)\n\ndef test_threshold_exceeded():\n    # エラー率が閾値を超える場合\n    logs = [(0, 500), (10, 500), (20, 200)]  # エラー率 = 2/3 > 0.5\n    result = solve(logs, 60, 0.5)\n    assert len(result) >= 1\n\ndef test_adjacent_intervals():\n    # 隣接する区間がマージされることを確認\n    logs = [(0, 500), (10, 500), (60, 500), (70, 500)]\n    result = solve(logs, 50, 0.5)\n    assert isinstance(result, list)\n    # マージ後は区間数が減るか、連続している\n    if len(result) > 1:\n        for i in range(len(result) - 1):\n            assert result[i][1] < result[i + 1][0]  # 隣接していない"
}
