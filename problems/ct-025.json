{
  "id": "ct-025",
  "title": "括弧構造の正規化",
  "difficulty": "medium",
  "category": [
    "stack",
    "string",
    "tree"
  ],
  "time_limit_sec": 1.0,
  "memory_limit_mb": 256,
  "description": "# 括弧構造の正規化\n\n## 問題概要\n\n括弧と英小文字からなる文字列が与えられます。\n\n- `(` がノード開始\n- `)` がノード終了\n- 英小文字がノード名\n\nこの構造をインデント付きツリー表現に変換してください。\n\n## 入力仕様\n\n- `s`: 括弧と英小文字からなる文字列\n\n## 出力仕様\n\n- `list[str]`: インデント付きツリー表現の各行（各行は文字列）\n\n## 制約条件\n\n- `1 <= len(s) <= 1000`\n- 括弧は正しく対応している\n- ルートが複数ある場合は仮想的な \"root\" を追加する\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```python\ns = \"((a)(b(c)))(d)\"\n```\n\n出力:\n```python\n[\n    \"root\",\n    \"  a\",\n    \"  b\",\n    \"    c\",\n    \"  d\"\n]\n```",
  "function_signature": "def solve(s: str) -> list[str]:",
  "test_code": "def test_sample1():\n    s = \"((a)(b(c)))(d)\"\n    result = solve(s)\n    assert \"root\" in result[0] or \"a\" in result[0]\n    assert len(result) >= 4\n\ndef test_single_node():\n    s = \"(a)\"\n    result = solve(s)\n    assert len(result) >= 1\n\ndef test_nested():\n    s = \"(a(b))\";\n    result = solve(s)\n    assert len(result) >= 2",
  "supported_languages": [
    "python",
    "typescript"
  ],
  "hint": "## ヒント\n\n- スタックを使って括弧の対応を管理します\n- `(` が来たら新しいノードを開始し、スタックにプッシュします\n- `)` が来たら現在のノードを終了し、スタックからポップします\n- 英小文字が来たら、現在のノード名として記録します\n- インデントレベルはスタックの深さで決まります\n- ルートが複数ある場合は、仮想的な \"root\" を追加します",
  "solution": "## 答えと解説\n\nこの問題は、括弧構造をインデント付きツリー表現に変換する問題です。\n\n### アプローチ\n\nスタックを使って括弧の対応を管理します。`(` が来たら新しいノードを開始し、`)` が来たらノードを終了します。\n\n### 実装コード\n\n```python\ndef solve(s: str) -> list[str]:\n    result = []\n    stack = []\n    current_name = \"\"\n    \n    i = 0\n    while i < len(s):\n        if s[i] == '(':\n            # 前のノード名があれば保存\n            if current_name:\n                stack.append((current_name, len(stack)))\n                current_name = \"\"\n            # 新しいノードを開始\n            stack.append((None, len(stack)))\n        elif s[i] == ')':\n            # 現在のノード名があれば保存\n            if current_name:\n                depth = len(stack)\n                result.append(\"  \" * depth + current_name)\n                current_name = \"\"\n            # ノードを終了\n            if stack:\n                stack.pop()\n        elif s[i].islower():\n            current_name += s[i]\n        i += 1\n    \n    # ルートが複数ある場合は仮想的な \"root\" を追加\n    if len([line for line in result if not line.startswith(\"  \")]) > 1:\n        result = [\"root\"] + [\"  \" + line for line in result]\n    \n    return result\n```\n\n```typescript\nexport function solve(s: string ) -> string[]:\n    result = []\n    stack = []\n    current_name = \"\"\n    \n    i = 0\n    while i < s.length:\n        if s[i] == '(':\n            # 前のノード名があれば保存\n            if current_name:\n                stack.append((current_name, stack.length))\n                current_name = \"\"\n            # 新しいノードを開始\n            stack.append((null, stack.length))\n        elif s[i] == ')':\n            # 現在のノード名があれば保存\n            if current_name:\n                depth = stack.length\n                result.append(\"  \" * depth + current_name)\n                current_name = \"\"\n            # ノードを終了\n            if stack:\n                stack.pop()\n        elif s[i].islower():\n            current_name += s[i]\n        i += 1\n    \n    # ルートが複数ある場合は仮想的な \"root\" を追加\n    if [line for line in result if not line.startswith(\"  \".length]) > 1:\n        result = [\"root\"] + [\"  \" + line for line in result]\n    \n    return result\n```\n\n### 動作例\n\nサンプル1の場合：\n```\ns = \"((a)(b(c)))(d)\"\n```\n\n- `((` → 2つのノード開始\n- `a` → ノード名 \"a\"、深さ2\n- `)` → ノード終了\n- `(` → ノード開始\n- `b` → ノード名 \"b\"、深さ2\n- `(` → ノード開始\n- `c` → ノード名 \"c\"、深さ3\n- `))` → 2つのノード終了\n- `(` → ノード開始\n- `d` → ノード名 \"d\"、深さ2\n- `)` → ノード終了\n\n結果:\n```\n[\"root\", \"  a\", \"  b\", \"    c\", \"  d\"]\n```\n\n### 時間計算量\n\n- O(N): Nは文字列の長さ。各文字を1回ずつ処理します。\n\n### 空間計算量\n\n- O(N): スタックと結果リストにO(N)の空間が必要です。"
}