{
  "id": "ct-030",
  "title": "依存関係の解決順",
  "difficulty": "hard",
  "category": ["graph", "topological-sort"],
  "time_limit_sec": 2.0,
  "memory_limit_mb": 512,
  "description": "# 依存関係の解決順\n\n## 問題概要\n\n依存関係が与えられます。指定されたノードを実行するための正しい実行順を1つ出力してください。\n\n## 入力仕様\n\n- `dependencies`: 依存関係のリスト。各要素は `(dependent, dependency)` のタプルで、`dependent` が `dependency` に依存することを表す\n- `target`: 実行対象のノード（文字列）\n\n## 出力仕様\n\n- `list[str]`: 実行順序（依存関係を満たす順序、複数解があってもよい）\n\n## 制約条件\n\n- `1 <= len(dependencies) <= 10^5`\n- 依存関係はDAG（有向非巡回グラフ）を形成する\n- すべてのノード名は文字列\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```python\ndependencies = [\n    (\"A\", \"B\"),\n    (\"A\", \"C\"),\n    (\"B\", \"D\")\n]\ntarget = \"A\"\n```\n\n出力:\n```python\n[\"D\", \"B\", \"C\", \"A\"]  # または [\"D\", \"C\", \"B\", \"A\"] など\n```",
  "function_signature": "def solve(dependencies: list[tuple[str, str]], target: str) -> list[str]:",
  "test_code": "def test_sample1():\n    deps = [(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"D\")]\n    result = solve(deps, \"A\")\n    assert \"A\" in result\n    assert \"B\" in result\n    assert \"C\" in result\n    assert \"D\" in result\n    # 順序チェック: D が B より前、B と C が A より前\n    assert result.index(\"D\") < result.index(\"B\")\n    assert result.index(\"B\") < result.index(\"A\")\n    assert result.index(\"C\") < result.index(\"A\")\n\ndef test_single_node():\n    result = solve([], \"A\")\n    assert result == [\"A\"]\n\ndef test_chain():\n    deps = [(\"A\", \"B\"), (\"B\", \"C\")]\n    result = solve(deps, \"A\")\n    assert result == [\"C\", \"B\", \"A\"]",
  "supported_languages": ["python", "typescript"],
  "hint": "## ヒント\n\n- トポロジカルソートを使います\n- 依存関係からグラフを構築します（dependent → dependency の有向辺）\n- 入次数（in-degree）を計算します\n- 入次数が0のノードから順に処理します（キューを使う）\n- 処理したノードの依存先の入次数を減らし、0になったらキューに追加します\n- ターゲットノードとその依存関係のみを考慮します",
  "solution": "## 答えと解説\n\nこの問題は、依存関係から実行順序を決定する問題です。トポロジカルソートを使って解きます。\n\n### アプローチ\n\n1. 依存関係からグラフを構築します（dependent → dependency の有向辺）\n2. 入次数（in-degree）を計算します\n3. 入次数が0のノードから順に処理します（キューを使う）\n4. ターゲットノードとその依存関係のみを考慮します\n\n### 実装コード\n\n```python\ndef solve(dependencies: list[tuple[str, str]], target: str) -> list[str]:\n    # グラフを構築（dependent → dependency の有向辺）\n    graph = {}\n    in_degree = {}\n    all_nodes = set()\n    \n    for dependent, dependency in dependencies:\n        if dependent not in graph:\n            graph[dependent] = []\n        graph[dependent].append(dependency)\n        all_nodes.add(dependent)\n        all_nodes.add(dependency)\n        \n        if dependency not in in_degree:\n            in_degree[dependency] = 0\n        if dependent not in in_degree:\n            in_degree[dependent] = 0\n        in_degree[dependency] += 1\n    \n    # ターゲットノードとその依存関係のみを考慮\n    # BFSでターゲットから到達可能なノードを収集\n    reachable = set()\n    queue = [target]\n    reachable.add(target)\n    \n    while queue:\n        node = queue.pop(0)\n        if node in graph:\n            for dep in graph[node]:\n                if dep not in reachable:\n                    reachable.add(dep)\n                    queue.append(dep)\n    \n    # 到達可能なノードのみでトポロジカルソート\n    filtered_in_degree = {node: in_degree.get(node, 0) for node in reachable}\n    filtered_graph = {node: [dep for dep in graph.get(node, []) if dep in reachable] \n                     for node in reachable if node in graph}\n    \n    # トポロジカルソート\n    result = []\n    queue = [node for node in reachable if filtered_in_degree[node] == 0]\n    \n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n        \n        if node in filtered_graph:\n            for dep in filtered_graph[node]:\n                filtered_in_degree[dep] -= 1\n                if filtered_in_degree[dep] == 0:\n                    queue.append(dep)\n    \n    return result\n```\n\n### 動作例\n\nサンプル1の場合：\n```\ndependencies = [(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"D\")]\ntarget = \"A\"\n```\n\n- グラフ: A → [B, C], B → [D]\n- 入次数: A=0, B=1, C=1, D=1\n- 初期キュー: [A]（ただし、Aは依存関係があるので、実際には依存関係を先に処理）\n- 実際の処理: D → B → C → A\n\n結果:\n```\n[\"D\", \"B\", \"C\", \"A\"]\n```\n\n### 時間計算量\n\n- O(V + E): Vはノード数、Eは辺の数。各ノードと辺を1回ずつ処理します。\n\n### 空間計算量\n\n- O(V + E): グラフとキューにO(V + E)の空間が必要です。"
}


