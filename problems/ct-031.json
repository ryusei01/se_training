{
  "id": "ct-031",
  "title": "差分構造の検出",
  "difficulty": "hard",
  "category": [
    "tree",
    "comparison",
    "dfs"
  ],
  "time_limit_sec": 2.0,
  "memory_limit_mb": 512,
  "description": "# 差分構造の検出\n\n## 問題概要\n\n2つのツリーが与えられます。追加されたノードと削除されたノードを列挙してください。\n\n## 入力仕様\n\n- `before`: 変更前のツリーのルートノード\n- `after`: 変更後のツリーのルートノード\n\n各ノードは以下のプロパティを持つ：\n- `name`: ノード名（文字列）\n- `children`: 子ノードのリスト\n\n## 出力仕様\n\n- `dict`: 以下の2つのプロパティを持つ辞書\n  - `added`: 追加されたノード名のリスト\n  - `removed`: 削除されたノード名のリスト\n\n## 制約条件\n\n- ノード数は 1 以上 1000 以下\n- ノード名は一意\n\n## サンプル入力・出力\n\n### サンプル1\n\nBefore:\n```\nA\n  B\n  C\n```\n\nAfter:\n```\nA\n  B\n  D\n```\n\n出力:\n```python\n{\n    \"added\": [\"D\"],\n    \"removed\": [\"C\"]\n}\n```",
  "function_signature": "def solve(before: dict, after: dict) -> dict:",
  "test_code": "def test_sample1():\n    before = {\"name\": \"A\", \"children\": [{\"name\": \"B\", \"children\": []}, {\"name\": \"C\", \"children\": []}]}\n    after = {\"name\": \"A\", \"children\": [{\"name\": \"B\", \"children\": []}, {\"name\": \"D\", \"children\": []}]}\n    result = solve(before, after)\n    assert \"D\" in result[\"added\"]\n    assert \"C\" in result[\"removed\"]\n\ndef test_no_changes():\n    tree = {\"name\": \"A\", \"children\": []}\n    result = solve(tree, tree)\n    assert len(result[\"added\"]) == 0\n    assert len(result[\"removed\"]) == 0",
  "supported_languages": [
    "python",
    "typescript"
  ],
  "hint": "## ヒント\n\n- 2つのツリーを同時にDFSで探索します\n- 同じ親ノードの下で、子ノードの集合を比較します\n- 変更前にあるが変更後にはないノード → 削除されたノード\n- 変更後にあるが変更前にはないノード → 追加されたノード\n- ノード名で比較します（位置ではなく名前で比較）",
  "solution": "## 答えと解説\n\nこの問題は、2つのツリーの差分を検出する問題です。\n\n### アプローチ\n\n2つのツリーを同時にDFSで探索します。同じ親ノードの下で、子ノードの集合を比較し、追加・削除されたノードを特定します。\n\n### 実装コード\n\n```python\ndef solve(before: dict, after: dict) -> dict:\n    added = []\n    removed = []\n    \n    def collect_nodes(node, node_set):\n        \"\"\"ノード名を収集\"\"\"\n        if node is None:\n            return\n        node_set.add(node[\"name\"])\n        for child in node.get(\"children\", []):\n            collect_nodes(child, node_set)\n    \n    def compare_trees(before_node, after_node):\n        \"\"\"2つのツリーを比較\"\"\"\n        if before_node is None and after_node is None:\n            return\n        \n        # 現在のノードの子ノードを比較\n        before_children = {child[\"name\"]: child for child in before_node.get(\"children\", [])} if before_node else {}\n        after_children = {child[\"name\"]: child for child in after_node.get(\"children\", [])} if after_node else {}\n        \n        # 削除されたノード\n        for name in before_children:\n            if name not in after_children:\n                removed.append(name)\n            else:\n                # 再帰的に比較\n                compare_trees(before_children[name], after_children[name])\n        \n        # 追加されたノード\n        for name in after_children:\n            if name not in before_children:\n                added.append(name)\n            # 既に処理済み（before_childrenに存在する場合）は上で処理済み\n    \n    compare_trees(before, after)\n    \n    return {\"added\": added, \"removed\": removed}\n```\n\n```typescript\nexport function solve(before: dict, after: dict) -> dict:\n    added = []\n    removed = []\n    \n    def collect_nodes(node, node_set):\n        \"\"\"ノード名を収集\"\"\"\n        if node is null:\n            return\n        node_set.add(node[\"name\"])\n        for child in node.get(\"children\", []):\n            collect_nodes(child, node_set)\n    \n    def compare_trees(before_node, after_node):\n        \"\"\"2つのツリーを比較\"\"\"\n        if before_node is null and after_node is null:\n            return\n        \n        # 現在のノードの子ノードを比較\n        before_children = {child[\"name\"]: child for child in before_node.get(\"children\", [])} if before_node else {}\n        after_children = {child[\"name\"]: child for child in after_node.get(\"children\", [])} if after_node else {}\n        \n        # 削除されたノード\n        for (const name of before_children) {\n            if name after_children.has(not):\n                removed.append(name)\n            else:\n                # 再帰的に比較\n                compare_trees(before_children[name], after_children[name])\n        \n        # 追加されたノード\n        for (const name of after_children) {\n            if name before_children.has(not):\n                added.append(name)\n            # 既に処理済み（before_childrenに存在する場合）は上で処理済み\n    \n    compare_trees(before, after)\n    \n    return {\"added\": added, \"removed\": removed}\n```\n\n### 動作例\n\nサンプル1の場合：\n```\nBefore:\nA\n  B\n  C\n\nAfter:\nA\n  B\n  D\n```\n\n- Aの子ノードを比較: Before=[B, C], After=[B, D]\n- CはAfterにない → 削除された\n- DはBeforeにない → 追加された\n\n結果:\n```\n{\"added\": [\"D\"], \"removed\": [\"C\"]}\n```\n\n### 時間計算量\n\n- O(N + M): NとMはそれぞれのツリーのノード数。各ノードを1回ずつ訪問します。\n\n### 空間計算量\n\n- O(N + M): 再帰のスタックと結果リストにO(N + M)の空間が必要です。"
}