{
  "id": "ct-029",
  "title": "DOM風ノードのシリアライズ",
  "difficulty": "medium",
  "category": ["tree", "recursion", "string"],
  "time_limit_sec": 1.0,
  "memory_limit_mb": 256,
  "description": "# DOM風ノードのシリアライズ\n\n## 問題概要\n\nDOM風のノード構造をHTML風文字列に変換してください。\n\n- 子がない場合: `<tag></tag>`\n- 子がある場合: 開始タグ → 子 → 終了タグ\n\n## 入力仕様\n\n- `root`: ルートノード。各ノードは以下のプロパティを持つ\n  - `tag`: タグ名（文字列）\n  - `children`: 子ノードのリスト（ノードのリスト）\n\n## 出力仕様\n\n- `str`: HTML風文字列\n\n## 制約条件\n\n- ノード数は 1 以上 1000 以下\n- タグ名は英小文字のみ\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```\ndiv\n ├─ p\n └─ span\n     └─ a\n```\n\n出力:\n```\n\"<div><p></p><span><a></a></span></div>\"\n```",
  "function_signature": "def solve(root: dict) -> str:",
  "test_code": "def test_sample1():\n    root = {\n        \"tag\": \"div\",\n        \"children\": [\n            {\"tag\": \"p\", \"children\": []},\n            {\n                \"tag\": \"span\",\n                \"children\": [{\"tag\": \"a\", \"children\": []}]\n            }\n        ]\n    }\n    result = solve(root)\n    assert \"<div>\" in result\n    assert \"<p></p>\" in result\n    assert \"<span>\" in result\n    assert \"<a></a>\" in result\n    assert result.endswith(\"</div>\")\n\ndef test_single_node():\n    root = {\"tag\": \"div\", \"children\": []}\n    result = solve(root)\n    assert result == \"<div></div>\"\n\ndef test_nested():\n    root = {\n        \"tag\": \"a\",\n        \"children\": [\n            {\"tag\": \"b\", \"children\": [{\"tag\": \"c\", \"children\": []}]}\n        ]\n    }\n    result = solve(root)\n    assert \"<a>\" in result and \"</a>\" in result\n    assert \"<b>\" in result and \"</b>\" in result\n    assert \"<c></c>\" in result",
  "supported_languages": ["python", "typescript"],
  "hint": "## ヒント\n\n- 再帰的にノードを処理します\n- 開始タグ `<tag>` を出力し、子ノードを再帰的に処理し、終了タグ `</tag>` を出力します\n- 子ノードがない場合は `<tag></tag>` の形式で出力します\n- 子ノードがある場合は、開始タグ、子ノード、終了タグの順で出力します",
  "solution": "## 答えと解説\n\nこの問題は、DOM風のノード構造をHTML風文字列に変換する問題です。\n\n### アプローチ\n\n再帰的にノードを処理します。各ノードについて、開始タグ、子ノード、終了タグの順で文字列を構築します。\n\n### 実装コード\n\n```python\ndef solve(root: dict) -> str:\n    def serialize(node):\n        if node is None:\n            return \"\"\n        \n        tag = node[\"tag\"]\n        children = node.get(\"children\", [])\n        \n        # 開始タグ\n        result = f\"<{tag}>\"\n        \n        # 子ノードを再帰的に処理\n        for child in children:\n            result += serialize(child)\n        \n        # 終了タグ\n        result += f\"</{tag}>\"\n        \n        return result\n    \n    return serialize(root)\n```\n\n### 動作例\n\nサンプル1の場合：\n```\ndiv\n ├─ p\n └─ span\n     └─ a\n```\n\n- `<div>` を開始\n- `<p></p>` を追加（子なし）\n- `<span>` を開始\n- `<a></a>` を追加（子なし）\n- `</span>` を終了\n- `</div>` を終了\n\n結果:\n```\n\"<div><p></p><span><a></a></span></div>\"\n```\n\n### 時間計算量\n\n- O(N): Nはノード数。各ノードを1回ずつ訪問します。\n\n### 空間計算量\n\n- O(H): Hは木の高さ。再帰のスタックが高さ分必要です。\n- 文字列の構築にO(N)の空間が必要です。"
}


