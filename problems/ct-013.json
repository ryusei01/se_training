{
  "id": "ct-013",
  "title": "テスト実行結果の集計と失敗分析",
  "difficulty": "hard",
  "category": [
    "array",
    "hash",
    "aggregation"
  ],
  "time_limit_sec": 2.0,
  "memory_limit_mb": 512,
  "description": "# テスト実行結果の集計と失敗分析\n\n## 問題概要\n\nE2Eテストの実行結果ログが与えられます。テストケースごとに最終結果と失敗原因の集計を行ってください。\n\n同じテストIDが複数回出現する可能性があり、失敗した後に再実行して成功する場合もあります。各テストIDの最終ステータスを求め、失敗した場合は最後に失敗したエラーメッセージを保持します。また、エラーメッセージごとに失敗回数を集計してください。\n\n## 入力仕様\n\n- `logs`: テストログのリスト。各ログは以下のプロパティを持つ\n  - `testId`: テストID（文字列）\n  - `timestamp`: タイムスタンプ（ミリ秒、整数）\n  - `status`: テストステータス（\"passed\" または \"failed\"）\n  - `errorMessage`: エラーメッセージ（オプション、失敗時のみ存在）\n\n## 出力仕様\n\n- `dict`: 以下の2つのプロパティを持つ辞書\n  - `finalStatusByTestId`: 各テストIDの最終ステータス（\"passed\" または \"failed\"）\n  - `failureCountByMessage`: エラーメッセージごとの失敗回数（エラーメッセージが存在する失敗のみカウント）\n\n## 制約条件\n\n- `0 <= len(logs) <= 10^5`\n- ログはタイムスタンプの昇順でソートされている\n- `0 <= timestamp <= 10^9`\n- 同じテストIDが複数回出現する可能性がある\n- `errorMessage` は失敗時のみ存在し、成功時は `undefined` または存在しない\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```typescript\nlogs = [\n  { testId: \"test1\", timestamp: 100, status: \"passed\" },\n  { testId: \"test2\", timestamp: 200, status: \"failed\", errorMessage: \"Timeout\" },\n  { testId: \"test2\", timestamp: 300, status: \"passed\" }\n]\n```\n\n出力:\n```typescript\n{\n  finalStatusByTestId: {\n    \"test1\": \"passed\",\n    \"test2\": \"passed\"\n  },\n  failureCountByMessage: {\n    \"Timeout\": 1\n  }\n}\n```\n\n### サンプル2\n\n入力:\n```typescript\nlogs = [\n  { testId: \"test1\", timestamp: 100, status: \"failed\", errorMessage: \"Assertion failed\" },\n  { testId: \"test1\", timestamp: 200, status: \"failed\", errorMessage: \"Timeout\" },\n  { testId: \"test2\", timestamp: 300, status: \"failed\" }\n]\n```\n\n出力:\n```typescript\n{\n  finalStatusByTestId: {\n    \"test1\": \"failed\",\n    \"test2\": \"failed\"\n  },\n  failureCountByMessage: {\n    \"Assertion failed\": 1,\n    \"Timeout\": 1\n  }\n}\n```\n\n### サンプル3（エラーメッセージなしの失敗）\n\n入力:\n```typescript\nlogs = [\n  { testId: \"test1\", timestamp: 100, status: \"failed\" },\n  { testId: \"test2\", timestamp: 200, status: \"failed\", errorMessage: \"Error\" }\n]\n```\n\n出力:\n```typescript\n{\n  finalStatusByTestId: {\n    \"test1\": \"failed\",\n    \"test2\": \"failed\"\n  },\n  failureCountByMessage: {\n    \"Error\": 1\n  }\n}\n```",
  "function_signature": "def solve(logs: list[dict]) -> dict:",
  "test_code": "def test_sample1():\n    logs = [\n        {\"testId\": \"test1\", \"timestamp\": 100, \"status\": \"passed\"},\n        {\"testId\": \"test2\", \"timestamp\": 200, \"status\": \"failed\", \"errorMessage\": \"Timeout\"},\n        {\"testId\": \"test2\", \"timestamp\": 300, \"status\": \"passed\"}\n    ]\n    result = solve(logs)\n    assert result[\"finalStatusByTestId\"][\"test1\"] == \"passed\"\n    assert result[\"finalStatusByTestId\"][\"test2\"] == \"passed\"\n    assert result[\"failureCountByMessage\"][\"Timeout\"] == 1\n\ndef test_sample2():\n    logs = [\n        {\"testId\": \"test1\", \"timestamp\": 100, \"status\": \"failed\", \"errorMessage\": \"Assertion failed\"},\n        {\"testId\": \"test1\", \"timestamp\": 200, \"status\": \"failed\", \"errorMessage\": \"Timeout\"},\n        {\"testId\": \"test2\", \"timestamp\": 300, \"status\": \"failed\"}\n    ]\n    result = solve(logs)\n    assert result[\"finalStatusByTestId\"][\"test1\"] == \"failed\"\n    assert result[\"finalStatusByTestId\"][\"test2\"] == \"failed\"\n    assert result[\"failureCountByMessage\"][\"Assertion failed\"] == 1\n    assert result[\"failureCountByMessage\"][\"Timeout\"] == 1\n\ndef test_sample3():\n    logs = [\n        {\"testId\": \"test1\", \"timestamp\": 100, \"status\": \"failed\"},\n        {\"testId\": \"test2\", \"timestamp\": 200, \"status\": \"failed\", \"errorMessage\": \"Error\"}\n    ]\n    result = solve(logs)\n    assert result[\"finalStatusByTestId\"][\"test1\"] == \"failed\"\n    assert result[\"finalStatusByTestId\"][\"test2\"] == \"failed\"\n    assert result[\"failureCountByMessage\"][\"Error\"] == 1\n    assert \"test1\" not in result[\"failureCountByMessage\"]\n\ndef test_all_passed():\n    logs = [\n        {\"testId\": \"test1\", \"timestamp\": 100, \"status\": \"passed\"},\n        {\"testId\": \"test2\", \"timestamp\": 200, \"status\": \"passed\"}\n    ]\n    result = solve(logs)\n    assert result[\"finalStatusByTestId\"][\"test1\"] == \"passed\"\n    assert result[\"finalStatusByTestId\"][\"test2\"] == \"passed\"\n    assert len(result[\"failureCountByMessage\"]) == 0\n\ndef test_all_failed():\n    logs = [\n        {\"testId\": \"test1\", \"timestamp\": 100, \"status\": \"failed\", \"errorMessage\": \"Error1\"},\n        {\"testId\": \"test2\", \"timestamp\": 200, \"status\": \"failed\", \"errorMessage\": \"Error2\"}\n    ]\n    result = solve(logs)\n    assert result[\"finalStatusByTestId\"][\"test1\"] == \"failed\"\n    assert result[\"finalStatusByTestId\"][\"test2\"] == \"failed\"\n    assert result[\"failureCountByMessage\"][\"Error1\"] == 1\n    assert result[\"failureCountByMessage\"][\"Error2\"] == 1\n\ndef test_retry_success():\n    logs = [\n        {\"testId\": \"test1\", \"timestamp\": 100, \"status\": \"failed\", \"errorMessage\": \"Error\"},\n        {\"testId\": \"test1\", \"timestamp\": 200, \"status\": \"failed\", \"errorMessage\": \"Error\"},\n        {\"testId\": \"test1\", \"timestamp\": 300, \"status\": \"passed\"}\n    ]\n    result = solve(logs)\n    assert result[\"finalStatusByTestId\"][\"test1\"] == \"passed\"\n    assert result[\"failureCountByMessage\"][\"Error\"] == 2\n\ndef test_same_error_multiple_tests():\n    logs = [\n        {\"testId\": \"test1\", \"timestamp\": 100, \"status\": \"failed\", \"errorMessage\": \"Timeout\"},\n        {\"testId\": \"test2\", \"timestamp\": 200, \"status\": \"failed\", \"errorMessage\": \"Timeout\"},\n        {\"testId\": \"test3\", \"timestamp\": 300, \"status\": \"failed\", \"errorMessage\": \"Timeout\"}\n    ]\n    result = solve(logs)\n    assert result[\"failureCountByMessage\"][\"Timeout\"] == 3\n\ndef test_empty_logs():\n    result = solve([])\n    assert len(result[\"finalStatusByTestId\"]) == 0\n    assert len(result[\"failureCountByMessage\"]) == 0",
  "supported_languages": [
    "python",
    "typescript"
  ],
  "hint": "## ヒント\n\nこの問題は**ログの集計と状態管理**が鍵となります。\n\n### 重要なポイント\n\n1. **最終ステータスの判定**: 同じテストIDが複数回出現する場合、最後のログが最終ステータス\n2. **エラーメッセージの集計**: 失敗したログのエラーメッセージをカウント（`errorMessage`が存在する場合のみ）\n3. **効率的な処理**: ログは時系列順なので、1回の走査で処理可能\n\n### 解法の流れ\n\n1. ハッシュマップ（辞書）を2つ用意\n   - `finalStatus`: 各テストIDの最終ステータスを保持\n   - `failureCount`: エラーメッセージごとの失敗回数をカウント\n2. ログを順番に処理\n   - 各ログで `finalStatus[testId]` を更新（常に最新の状態を保持）\n   - `status == \"failed\"` かつ `errorMessage` が存在する場合、`failureCount[errorMessage]` をインクリメント\n3. 結果を返す\n\n### 注意点\n\n- `errorMessage` が `undefined` や存在しない失敗ログは、`failureCountByMessage` には含めない\n- 最終ステータスは「最後に出現したログ」のステータス",
  "solution": "## 答えと解説\n\n### 解法\n\n```python\ndef solve(logs: list[dict]) -> dict:\n    final_status = {}\n    failure_count = {}\n    \n    for log in logs:\n        test_id = log[\"testId\"]\n        status = log[\"status\"]\n        \n        # 最終ステータスを更新（常に最新の状態を保持）\n        final_status[test_id] = status\n        \n        # 失敗かつエラーメッセージがある場合のみカウント\n        if status == \"failed\" and \"errorMessage\" in log and log[\"errorMessage\"]:\n            error_msg = log[\"errorMessage\"]\n            failure_count[error_msg] = failure_count.get(error_msg, 0) + 1\n    \n    return {\n        \"finalStatusByTestId\": final_status,\n        \"failureCountByMessage\": failure_count\n    }\n```\n\n```typescript\nexport function solve(logs: list[dict]) -> dict:\n    final_status = {}\n    failure_count = {}\n    \n    for (const log of logs) {\n        test_id = log[\"testId\"]\n        status = log[\"status\"]\n        \n        # 最終ステータスを更新（常に最新の状態を保持）\n        final_status[test_id] = status\n        \n        # 失敗かつエラーメッセージがある場合のみカウント\n        if status == \"failed\" and \"errorMessage\" in log and log[\"errorMessage\"]:\n            error_msg = log[\"errorMessage\"]\n            failure_count[error_msg] = failure_count.get(error_msg, 0) + 1\n    \n    return {\n        \"finalStatusByTestId\": final_status,\n        \"failureCountByMessage\": failure_count\n    }\n```\n\n### 解説\n\n1. **状態の更新**: ログを順番に処理し、各テストIDの最終ステータスを常に最新の状態で更新\n2. **エラー集計**: 失敗ログでエラーメッセージが存在する場合のみ、そのメッセージのカウントを増やす\n3. **効率性**: O(n) の時間計算量で処理可能（n はログ数）\n\n### 具体例\n\n```python\nlogs = [\n    {\"testId\": \"test1\", \"status\": \"passed\"},\n    {\"testId\": \"test2\", \"status\": \"failed\", \"errorMessage\": \"Timeout\"},\n    {\"testId\": \"test2\", \"status\": \"passed\"}\n]\n```\n\n```typescript\nlogs = [\n    {\"testId\": \"test1\", \"status\": \"passed\"},\n    {\"testId\": \"test2\", \"status\": \"failed\", \"errorMessage\": \"Timeout\"},\n    {\"testId\": \"test2\", \"status\": \"passed\"}\n]\n```\n\n処理の流れ：\n1. test1: passed → `final_status[\"test1\"] = \"passed\"`\n2. test2: failed (Timeout) → `final_status[\"test2\"] = \"failed\"`, `failure_count[\"Timeout\"] = 1`\n3. test2: passed → `final_status[\"test2\"] = \"passed\"`（上書き）\n\n結果：`{\"test1\": \"passed\", \"test2\": \"passed\"}`, `{\"Timeout\": 1}`\n\n### 時間計算量\n\n- **時間計算量**: O(n) ここで n はログ数\n- **空間計算量**: O(n) 最悪の場合、すべてのテストIDとエラーメッセージが異なる"
}