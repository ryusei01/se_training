{
  "id": "ct-028",
  "title": "親IDリストから木構造構築",
  "difficulty": "medium",
  "category": ["tree", "graph", "hash"],
  "time_limit_sec": 1.0,
  "memory_limit_mb": 256,
  "description": "# 親IDリストから木構造構築\n\n## 問題概要\n\n親子関係を表す配列が与えられます。これをツリーとして構築し、インデント表示してください。\n\n## 入力仕様\n\n- `nodes`: ノードのリスト。各ノードは以下のプロパティを持つ\n  - `id`: ノードID（整数）\n  - `parent`: 親ノードID（整数または `null`、`null` の場合はルート）\n\n## 出力仕様\n\n- `list[str]`: インデント付きツリー表現の各行\n\n## 制約条件\n\n- `1 <= len(nodes) <= 1000`\n- すべてのノードIDは一意\n- ルートノードは1つだけ存在する\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```python\nnodes = [\n    {\"id\": 1, \"parent\": None},\n    {\"id\": 2, \"parent\": 1},\n    {\"id\": 3, \"parent\": 1},\n    {\"id\": 4, \"parent\": 2},\n    {\"id\": 5, \"parent\": 2}\n]\n```\n\n出力:\n```python\n[\n    \"1\",\n    \"  2\",\n    \"    4\",\n    \"    5\",\n    \"  3\"\n]\n```",
  "function_signature": "def solve(nodes: list[dict]) -> list[str]:",
  "test_code": "def test_sample1():\n    nodes = [\n        {\"id\": 1, \"parent\": None},\n        {\"id\": 2, \"parent\": 1},\n        {\"id\": 3, \"parent\": 1},\n        {\"id\": 4, \"parent\": 2},\n        {\"id\": 5, \"parent\": 2}\n    ]\n    result = solve(nodes)\n    assert \"1\" in result[0]\n    assert len(result) == 5\n\ndef test_single_node():\n    nodes = [{\"id\": 1, \"parent\": None}]\n    result = solve(nodes)\n    assert len(result) == 1\n    assert \"1\" in result[0]",
  "supported_languages": ["python", "typescript"],
  "hint": "## ヒント\n\n- 親子関係のマップを作成します\n- ルートノード（parentがNone）を見つけます\n- DFSまたはBFSを使って、ルートから順にツリーを構築します\n- インデントレベルは再帰の深さで決まります\n- 各ノードを訪問したら、インデント付きで結果リストに追加します",
  "solution": "## 答えと解説\n\nこの問題は、親子関係のリストから木構造を構築し、インデント表示する問題です。\n\n### アプローチ\n\n1. 親子関係のマップを作成します\n2. ルートノード（parentがNone）を見つけます\n3. DFSを使って、ルートから順にツリーを構築します\n\n### 実装コード\n\n```python\ndef solve(nodes: list[dict]) -> list[str]:\n    result = []\n    \n    # 親子関係のマップを作成\n    children_map = {}\n    node_map = {}\n    root_id = None\n    \n    for node in nodes:\n        node_id = node[\"id\"]\n        parent_id = node[\"parent\"]\n        node_map[node_id] = node\n        \n        if parent_id is None:\n            root_id = node_id\n        else:\n            if parent_id not in children_map:\n                children_map[parent_id] = []\n            children_map[parent_id].append(node_id)\n    \n    # DFSでツリーを構築\n    def dfs(node_id, depth):\n        result.append(\"  \" * depth + str(node_id))\n        \n        if node_id in children_map:\n            for child_id in children_map[node_id]:\n                dfs(child_id, depth + 1)\n    \n    if root_id is not None:\n        dfs(root_id, 0)\n    \n    return result\n```\n\n### 動作例\n\nサンプル1の場合：\n```\nnodes = [\n    {\"id\": 1, \"parent\": None},\n    {\"id\": 2, \"parent\": 1},\n    {\"id\": 3, \"parent\": 1},\n    {\"id\": 4, \"parent\": 2},\n    {\"id\": 5, \"parent\": 2}\n]\n```\n\n- ルート: 1\n- 1の子: 2, 3\n- 2の子: 4, 5\n\n結果:\n```\n[\"1\", \"  2\", \"    4\", \"    5\", \"  3\"]\n```\n\n### 時間計算量\n\n- O(N): Nはノード数。各ノードを1回ずつ訪問します。\n\n### 空間計算量\n\n- O(N): マップと結果リストにO(N)の空間が必要です。"
}


