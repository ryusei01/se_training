{
  "id": "ct-003",
  "title": "依存関係を持つタスクの最短完了時間",
  "difficulty": "hard",
  "category": [
    "graph",
    "topological-sort",
    "dynamic-programming"
  ],
  "time_limit_sec": 2.0,
  "memory_limit_mb": 512,
  "description": "# 依存関係を持つタスクの最短完了時間\n\n## 問題概要\n\nn個のタスクがあり、それぞれに実行時間が設定されています。タスク間には依存関係があり、あるタスクは他のタスクが完了してから実行できます。タスクは依存関係が満たされていれば並列実行可能です。すべてのタスクを完了するのに必要な最短時間を求めてください。\n\n## 入力仕様\n\n- `n`: タスクの数（1以上）\n- `durations`: 各タスクの実行時間のリスト（長さ: n）\n- `dependencies`: 依存関係のリスト。各要素は `(from_task, to_task)` のタプルで、`from_task` が完了してから `to_task` を実行できることを表す\n\n## 出力仕様\n\n- `int`: すべてのタスクを完了するのに必要な最短時間\n\n## 制約条件\n\n- `1 <= n <= 10^5`\n- `1 <= durations[i] <= 10^4`\n- `0 <= len(dependencies) <= 2 * 10^5`\n- 依存関係はDAG（有向非巡回グラフ）を形成する（サイクルは存在しない）\n- `0 <= from_task, to_task < n`\n\n## サンプル入力・出力\n\n### サンプル1（最小ケース）\n\n入力:\n```python\nn = 1\ndurations = [5]\ndependencies = []\n```\n\n出力:\n```python\n5\n```\n\n### サンプル2（直列依存）\n\n入力:\n```python\nn = 3\ndurations = [2, 3, 4]\ndependencies = [(0, 1), (1, 2)]\n```\n\n出力:\n```python\n9  # 2 + 3 + 4 = 9（順番に実行）\n```\n\n### サンプル3（完全並列）\n\n入力:\n```python\nn = 3\ndurations = [3, 5, 7]\ndependencies = []\n```\n\n出力:\n```python\n7  # すべて並列実行可能、最長の7が全体の完了時間\n```\n\n### サンプル4（合流パターン）\n\n入力:\n```python\nn = 3\ndurations = [3, 2, 5]\ndependencies = [(0, 2), (1, 2)]\n```\n\n出力:\n```python\n8  # タスク0と1は並列実行（max(3,2)=3）、その後タスク2を実行（3+5=8）\n```",
  "function_signature": "def solve(n: int, durations: list[int], dependencies: list[tuple[int, int]]) -> int:",
  "test_code": "def test_sample1():\n    assert solve(1, [5], []) == 5\n\ndef test_sample2():\n    assert solve(3, [2, 3, 4], [(0, 1), (1, 2)]) == 9\n\ndef test_sample3():\n    assert solve(3, [3, 5, 7], []) == 7\n\ndef test_sample4():\n    assert solve(3, [3, 2, 5], [(0, 2), (1, 2)]) == 8\n\ndef test_single_task():\n    assert solve(1, [10], []) == 10\n\ndef test_two_parallel():\n    assert solve(2, [5, 3], []) == 5\n\ndef test_two_sequential():\n    assert solve(2, [5, 3], [(0, 1)]) == 8\n\ndef test_complex_dag():\n    # タスク0,1 -> タスク2 -> タスク3,4 -> タスク5\n    durations = [1, 2, 3, 4, 5, 6]\n    deps = [(0, 2), (1, 2), (2, 3), (2, 4), (3, 5), (4, 5)]\n    # パス: max(1,2)+3+max(4,5)+6 = 2+3+5+6 = 16\n    assert solve(6, durations, deps) == 16\n\ndef test_fork_join():\n    # タスク0 -> タスク1,2 -> タスク3\n    durations = [1, 2, 3, 4]\n    deps = [(0, 1), (0, 2), (1, 3), (2, 3)]\n    # パス: 1+max(2,3)+4 = 1+3+4 = 8\n    assert solve(4, durations, deps) == 8",
  "hint": "## ヒント\n\nこの問題は**DAG（有向非巡回グラフ）の最長パス問題**として解くことができます。\n\n### 重要なポイント\n\n1. **トポロジカルソート**: 依存関係を満たす順序でタスクを処理する\n2. **動的計画法**: 各タスクの完了時刻を計算する\n3. **並列実行の考慮**: 複数のタスクが同じタスクに依存している場合、それらの最大完了時刻を考慮する\n\n### 解法の流れ\n\n1. 依存関係からグラフを構築（隣接リスト）\n2. トポロジカルソートでタスクを順序付け\n3. 各タスクについて、依存するタスクの最大完了時刻を計算\n4. タスクの完了時刻 = 依存タスクの最大完了時刻 + 自身の実行時間\n5. すべてのタスクの完了時刻の最大値が答え\n\n### 具体例\n\nタスク0(3), タスク1(2) → タスク2(5) の場合：\n- タスク0と1は並列実行可能 → 完了時刻は max(3, 2) = 3\n- タスク2は両方の完了を待つ → 完了時刻は 3 + 5 = 8",
  "solution": "## 答えと解説\n\n### 解法\n\n```python\ndef solve(n: int, durations: list[int], dependencies: list[tuple[int, int]]) -> int:\n    # グラフ構築\n    graph = [[] for _ in range(n)]\n    in_degree = [0] * n\n    \n    for from_task, to_task in dependencies:\n        graph[from_task].append(to_task)\n        in_degree[to_task] += 1\n    \n    # トポロジカルソート（BFSベース）\n    queue = []\n    completion_time = [0] * n\n    \n    # 依存関係がないタスクから開始\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n            completion_time[i] = durations[i]\n    \n    # BFSで順次処理\n    while queue:\n        current = queue.pop(0)\n        \n        for next_task in graph[current]:\n            # 依存タスクの最大完了時刻を更新\n            completion_time[next_task] = max(\n                completion_time[next_task],\n                completion_time[current]\n            )\n            \n            in_degree[next_task] -= 1\n            if in_degree[next_task] == 0:\n                # すべての依存が解決したら実行開始\n                completion_time[next_task] += durations[next_task]\n                queue.append(next_task)\n    \n    return max(completion_time)\n```\n\n```typescript\nexport function solve(n: number , durations: number[], dependencies: [number, number][]) : number {\n    # グラフ構築\n    graph = [[] for _ in range(n)]\n    in_degree = [0] * n\n    \n    for from_task, dependencies.has(to_task):\n        graph[from_task].append(to_task)\n        in_degree[to_task] += 1\n    \n    # トポロジカルソート（BFSベース）\n    queue = []\n    completion_time = [0] * n\n    \n    # 依存関係がないタスクから開始\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n            completion_time[i] = durations[i]\n    \n    # BFSで順次処理\n    while queue:\n        current = queue.pop(0)\n        \n        for next_task in graph[current]:\n            # 依存タスクの最大完了時刻を更新\n            completion_time[next_task] = max(\n                completion_time[next_task],\n                completion_time[current]\n            )\n            \n            in_degree[next_task] -= 1\n            if in_degree[next_task] == 0:\n                # すべての依存が解決したら実行開始\n                completion_time[next_task] += durations[next_task]\n                queue.append(next_task)\n    \n    return max(completion_time)\n```\n\n### 解説\n\n1. **グラフ構築**: 依存関係から有向グラフを構築し、各ノードの入次数を計算\n2. **トポロジカルソート**: 入次数が0のタスク（依存がない）から処理を開始\n3. **完了時刻の計算**: \n   - 依存タスクの最大完了時刻を追跡\n   - すべての依存が解決した時点で、その最大値 + 自身の実行時間を完了時刻とする\n4. **答え**: すべてのタスクの完了時刻の最大値\n\n### 時間計算量\n\n- **時間計算量**: O(n + m) ここで n はタスク数、m は依存関係の数\n- **空間計算量**: O(n + m)\n\n### ポイント\n\n- 並列実行可能なタスクは、依存関係が満たされ次第即座に開始できる\n- 複数のタスクが同じタスクに依存する場合、それらの最大完了時刻を待つ必要がある\n- これはプロジェクト管理の「クリティカルパス」問題と同じ構造"
}