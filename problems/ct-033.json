{
  "id": "ct-033",
  "title": "コードリーディング：再帰関数の動作解析",
  "difficulty": "medium",
  "category": ["tree", "recursion", "code-reading"],
  "time_limit_sec": 1.0,
  "memory_limit_mb": 256,
  "description": "# コードリーディング：再帰関数の動作解析\n\n## 問題概要\n\n以下の関数が何を計算しているか説明し、具体例で検算してください。\n\n```typescript\ntype Node = { v: number; l?: Node; r?: Node };\n\nfunction f(n: Node | undefined, acc: number): number {\n  if (!n) return 0;\n  const next = acc * 10 + n.v;\n  if (!n.l && !n.r) return next;\n  return f(n.l, next) + f(n.r, next);\n}\n```\n\n## 入力仕様\n\n- `root`: 二分木のルートノード。各ノードは以下のプロパティを持つ\n  - `v`: ノードの値（0-9の整数）\n  - `l`: 左の子ノード（ノードまたは `None`）\n  - `r`: 右の子ノード（ノードまたは `None`）\n\n## 出力仕様\n\n- `int`: 関数の戻り値\n\n## 制約条件\n\n- ノード数は 1 以上 1000 以下\n- `0 <= v <= 9`\n\n## 説明\n\nこの関数は、**ルートから葉までの各経路を整数として解釈し、それらの合計を返します**。\n\n- `acc` は現在までの経路を整数として表現した値\n- 葉ノードに到達したら、その時点の `next`（経路を整数として解釈した値）を返す\n- 内部ノードでは、左右の子ノードの結果を合計\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```\n    1\n   / \\\n  2   3\n```\n\n出力:\n```\n25  # 経路1: 1→2 = 12\n    # 経路2: 1→3 = 13\n    # 合計: 12+13=25\n```",
  "function_signature": "def solve(root: dict) -> int:",
  "test_code": "def test_sample1():\n    root = {\"v\": 1, \"l\": {\"v\": 2, \"l\": None, \"r\": None}, \"r\": {\"v\": 3, \"l\": None, \"r\": None}}\n    result = solve(root)\n    # 経路: 12, 13 → 合計=25\n    assert result == 25\n\ndef test_single_node():\n    root = {\"v\": 5, \"l\": None, \"r\": None}\n    assert solve(root) == 5\n\ndef test_three_levels():\n    root = {\"v\": 1, \"l\": {\"v\": 0, \"l\": {\"v\": 5, \"l\": None, \"r\": None}, \"r\": None}, \"r\": None}\n    result = solve(root)\n    # 経路: 105\n    assert result == 105",
  "supported_languages": ["python", "typescript"]
}
