{
  "id": "ct-027",
  "title": "イベントログから構造復元",
  "difficulty": "medium",
  "category": ["stack", "tree", "parsing"],
  "time_limit_sec": 1.0,
  "memory_limit_mb": 256,
  "description": "# イベントログから構造復元\n\n## 問題概要\n\nログは「処理の開始・終了」を表します。\n\n- `enter X`: 処理Xの開始\n- `exit X`: 処理Xの終了\n\nこれをツリー構造として復元し、インデント表示してください。\n\n## 入力仕様\n\n- `logs`: ログのリスト。各ログは文字列で、`\"enter X\"` または `\"exit X\"` の形式\n\n## 出力仕様\n\n- `list[str]`: インデント付きツリー表現の各行\n\n## 制約条件\n\n- `1 <= len(logs) <= 1000`\n- `enter X` と `exit X` は必ず対応する\n- ネストは正しい\n\n## サンプル入力・出力\n\n### サンプル1\n\n入力:\n```python\nlogs = [\n    \"enter A\",\n    \"enter B\",\n    \"exit B\",\n    \"enter C\",\n    \"exit C\",\n    \"exit A\"\n]\n```\n\n出力:\n```python\n[\n    \"A\",\n    \"  B\",\n    \"  C\"\n]\n```",
  "function_signature": "def solve(logs: list[str]) -> list[str]:",
  "test_code": "def test_sample1():\n    logs = [\n        \"enter A\",\n        \"enter B\",\n        \"exit B\",\n        \"enter C\",\n        \"exit C\",\n        \"exit A\"\n    ]\n    result = solve(logs)\n    assert \"A\" in result[0]\n    assert \"B\" in \"\".join(result) or \"C\" in \"\".join(result)\n    assert len(result) >= 2\n\ndef test_single_node():\n    logs = [\"enter X\", \"exit X\"]\n    result = solve(logs)\n    assert len(result) == 1\n\ndef test_nested():\n    logs = [\n        \"enter A\",\n        \"enter B\",\n        \"enter C\",\n        \"exit C\",\n        \"exit B\",\n        \"exit A\"\n    ]\n    result = solve(logs)\n    assert len(result) >= 3",
  "supported_languages": ["python", "typescript"],
  "hint": "## ヒント\n\n- スタックを使って、処理の入れ子構造を管理します\n- `enter X` が来たら、新しいノードを開始し、スタックにプッシュします\n- `exit X` が来たら、現在のノードを終了し、スタックからポップします\n- インデントレベルはスタックの深さで決まります\n- ノード名とインデントレベルを記録して、結果リストに追加します",
  "solution": "## 答えと解説\n\nこの問題は、イベントログ（enter/exit）からツリー構造を復元する問題です。\n\n### アプローチ\n\nスタックを使って、処理の入れ子構造を管理します。`enter` が来たら新しいノードを開始し、`exit` が来たらノードを終了します。\n\n### 実装コード\n\n```python\ndef solve(logs: list[str]) -> list[str]:\n    result = []\n    stack = []  # (ノード名, インデントレベル) のスタック\n    \n    for log in logs:\n        parts = log.split()\n        action = parts[0]\n        name = parts[1]\n        \n        if action == \"enter\":\n            # 新しいノードを開始\n            depth = len(stack)\n            result.append(\"  \" * depth + name)\n            stack.append((name, depth))\n        elif action == \"exit\":\n            # ノードを終了（スタックからポップ）\n            if stack and stack[-1][0] == name:\n                stack.pop()\n    \n    return result\n```\n\n### 動作例\n\nサンプル1の場合：\n```\n[\"enter A\", \"enter B\", \"exit B\", \"enter C\", \"exit C\", \"exit A\"]\n```\n\n- `enter A` → スタック: [(A, 0)], 結果: [\"A\"]\n- `enter B` → スタック: [(A, 0), (B, 1)], 結果: [\"A\", \"  B\"]\n- `exit B` → スタック: [(A, 0)]\n- `enter C` → スタック: [(A, 0), (C, 1)], 結果: [\"A\", \"  B\", \"  C\"]\n- `exit C` → スタック: [(A, 0)]\n- `exit A` → スタック: []\n\n結果:\n```\n[\"A\", \"  B\", \"  C\"]\n```\n\n### 時間計算量\n\n- O(N): Nはログの数。各ログを1回ずつ処理します。\n\n### 空間計算量\n\n- O(N): スタックと結果リストにO(N)の空間が必要です。"
}


