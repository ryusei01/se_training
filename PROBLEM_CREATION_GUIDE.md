# 問題作成ガイド

このガイドでは、コーディングテスト用の問題を効果的に作成する方法を説明します。

## 目次

1. [問題作成の全体フロー](#問題作成の全体フロー)
2. [JSONファイルの構造](#jsonファイルの構造)
3. [問題文の書き方](#問題文の書き方)
4. [テストケースの設計](#テストケースの設計)
5. [難易度別の推奨事項](#難易度別の推奨事項)
6. [よくあるミスと回避方法](#よくあるミスと回避方法)
7. [実例](#実例)

## 問題作成の全体フロー

### ステップ1: 問題のアイデアを考える

- **アルゴリズム・データ構造**: どのアルゴリズムやデータ構造をテストしたいか
- **難易度**: easy / medium / hard のどれにするか
- **実用性**: 実際の開発で使われるような問題か

### ステップ2: 問題文を設計する

1. **問題概要**: 何を求めればよいか簡潔に説明
2. **入力仕様**: 入力の形式と意味を明確に
3. **出力仕様**: 出力の形式と意味を明確に
4. **制約条件**: 入力の範囲や制限を明記
5. **サンプル**: 理解を助ける具体例を複数提示

### ステップ3: 関数シグネチャを決める

- Python形式で記述（TypeScriptは自動変換）
- 型ヒントを明確に
- 関数名は `solve` として扱われる（テストコード内で使用）

### ステップ4: テストケースを設計する

1. **公開テストケース**: 仕様理解と基本動作確認
2. **非公開テストケース**: 計算量、境界条件、エッジケース

### ステップ5: JSONファイルを作成する

`problems/{problem_id}.json` として保存

## JSONファイルの構造

### 基本構造

```json
{
  "id": "ct-XXX",
  "title": "問題のタイトル",
  "difficulty": "easy | medium | hard",
  "category": ["category1", "category2"],
  "time_limit_sec": 1.0,
  "memory_limit_mb": 256,
  "description": "# Markdown形式の問題文...",
  "function_signature": "def solve(...) -> ...:",
  "test_code": "def test_...(): ...",
  "supported_languages": ["python", "typescript"]
}
```

### 各フィールドの詳細

#### `id` (必須)

- 形式: `"ct-XXX"` (XXXは3桁の数字)
- 例: `"ct-001"`, `"ct-003"`
- 注意: 既存の問題IDと重複しないこと

#### `title` (必須)

- 問題のタイトル（日本語可）
- 簡潔で分かりやすいもの
- 例: `"配列内の2数の和"`, `"依存関係を持つタスクの最短完了時間"`

#### `difficulty` (必須)

- `"easy"`: 初心者向け、基本的なアルゴリズム
- `"medium"`: 中級者向け、複数の概念の組み合わせ
- `"hard"`: 上級者向け、高度なアルゴリズムや最適化が必要

#### `category` (必須)

- アルゴリズム・データ構造のカテゴリのリスト
- よく使われるカテゴリ:
  - `"array"`, `"string"`, `"hash"`, `"tree"`, `"graph"`
  - `"dynamic-programming"`, `"greedy"`, `"binary-search"`
  - `"heap"`, `"segment-tree"`, `"topological-sort"`
- 複数指定可能: `["array", "hash"]`

#### `time_limit_sec` (必須)

- 実行時間制限（秒）
- 推奨値:
  - easy: `1.0`
  - medium: `1.0` - `2.0`
  - hard: `2.0` - `5.0`

#### `memory_limit_mb` (必須)

- メモリ制限（MB）
- 推奨値:
  - 小規模: `256`
  - 中規模: `512`
  - 大規模: `1024`

#### `description` (必須)

- Markdown形式の問題文
- 詳細は[問題文の書き方](#問題文の書き方)を参照

#### `function_signature` (必須)

- Python形式の関数シグネチャ
- 型ヒントを含める
- 例:
  ```python
  def solve(nums: list[int], target: int) -> bool:
  def solve(n: int, durations: list[int], dependencies: list[tuple[int, int]]) -> int:
  ```

#### `test_code` (必須)

- pytest形式のテストコード
- 複数のテスト関数を含める
- 詳細は[テストケースの設計](#テストケースの設計)を参照

#### `supported_languages` (オプション)

- 対応言語のリスト
- デフォルト: `["python"]`
- TypeScript対応: `["python", "typescript"]`

## 問題文の書き方

### 必須セクション

問題文（`description`）には以下のセクションを含めてください。

#### 1. 問題概要

- 何を求めればよいかを簡潔に説明
- 1-3文で要点を伝える

例:
```markdown
## 問題概要

整数の配列 `nums` と目標値 `target` が与えられます。配列内の2つの数の和が `target` と等しくなる組み合わせが存在するかどうかを判定してください。
```

#### 2. 入力仕様

- 各入力パラメータの説明
- データ型と意味を明確に

例:
```markdown
## 入力仕様

- `nums`: 整数のリスト（長さ: 2以上）
- `target`: 整数（目標値）
```

#### 3. 出力仕様

- 出力の形式と意味
- 戻り値の型と意味を明確に

例:
```markdown
## 出力仕様

- `bool`: 2つの数の和が `target` と等しくなる組み合わせが存在すれば `True`、そうでなければ `False`
```

#### 4. 制約条件

- 入力の範囲や制限
- 数値の範囲を明記
- 特殊な条件があれば記載

例:
```markdown
## 制約条件

- `2 <= len(nums) <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- 同じ要素を2回使用することはできません
```

#### 5. サンプル入力・出力

- 複数のサンプルを提示（最低3-4個推奨）
- 各サンプルに説明コメントを付ける
- 様々なパターンを含める

例:
```markdown
## サンプル入力・出力

### サンプル1

入力:
```python
nums = [2, 7, 11, 15]
target = 9
```

出力:
```python
True  # 2 + 7 = 9
```

### サンプル2

入力:
```python
nums = [3, 3]
target = 6
```

出力:
```python
True  # 3 + 3 = 6
```
```

### 問題文のベストプラクティス

1. **明確性**: 曖昧な表現を避ける
2. **具体性**: 抽象的な説明だけでなく、具体例を示す
3. **一貫性**: 用語を統一する
4. **完全性**: 必要な情報をすべて含める
5. **可読性**: Markdownの見出しやコードブロックを活用

## テストケースの設計

### テストケースの種類

#### 1. サンプルテストケース（公開）

- 問題文のサンプルに対応
- 仕様理解の確認
- 基本的な動作確認

```python
def test_sample1():
    assert solve([2, 7, 11, 15], 9) == True

def test_sample2():
    assert solve([3, 3], 6) == True
```

#### 2. エッジケース（公開/非公開）

- 最小ケース: 入力が最小値
- 最大ケース: 入力が最大値
- 空の入力: 空配列、空文字列など
- 単一要素: 要素が1つだけ

```python
def test_single_element():
    assert solve([5], 5) == False  # 同じ要素を2回使えない

def test_minimum():
    assert solve([1, 1], 2) == True
```

#### 3. 境界条件（非公開）

- 制約条件の境界値
- オーバーフロー/アンダーフローの可能性
- 浮動小数点誤差

```python
def test_boundary():
    # 制約の境界値
    nums = list(range(10**4))
    assert solve(nums, 19998) == True
```

#### 4. 計算量テスト（非公開）

- 大規模入力での性能確認
- 想定アルゴリズムで解けることを確認
- 非効率な実装を排除

```python
def test_large_input():
    n = 100000
    # O(n) または O(n log n) で解けることを確認
    ...
```

#### 5. 特殊パターン（非公開）

- コーナーケース
- 実装ミスを検出しやすいケース
- 複数の条件が重なるケース

```python
def test_negative_numbers():
    assert solve([-1, 0, 1], 0) == True

def test_all_same():
    assert solve([1, 1, 1, 1], 2) == True
```

### テストケース設計のベストプラクティス

1. **網羅性**: 様々なパターンをカバー
2. **明確性**: テスト名で意図を明確に
3. **独立性**: 各テストは独立して実行可能
4. **検証可能性**: 期待値が明確
5. **バランス**: 公開/非公開のバランスを取る

### テストコードの命名規則

- `test_sample{N}`: サンプルケース
- `test_edge_case{N}`: エッジケース
- `test_boundary`: 境界条件
- `test_large_input`: 大規模入力
- `test_{specific_pattern}`: 特定のパターン

例:
```python
def test_sample1(): ...
def test_edge_case1(): ...
def test_negative_numbers(): ...
def test_large_array(): ...
```

## 難易度別の推奨事項

### Easy

- **アルゴリズム**: 基本的な配列操作、ループ、条件分岐
- **データ構造**: 配列、文字列、ハッシュテーブル
- **計算量**: O(n) または O(n²) で十分
- **テストケース**: 5-8個程度
- **時間制限**: 1.0秒

例: 配列の最大値、文字列の反転、2数の和

### Medium

- **アルゴリズム**: 動的計画法、二分探索、グラフ探索
- **データ構造**: 木、グラフ、スタック、キュー
- **計算量**: O(n log n) または O(n²) が想定
- **テストケース**: 8-12個程度
- **時間制限**: 1.0-2.0秒

例: 最大部分和、二分探索、BFS/DFS

### Hard

- **アルゴリズム**: 高度なDP、セグメントツリー、複雑なグラフアルゴリズム
- **データ構造**: 高度なデータ構造の組み合わせ
- **計算量**: O(n log n) または O(n) が必須
- **テストケース**: 10-15個程度
- **時間制限**: 2.0-5.0秒

例: DAGの最長パス、セグメントツリー、複雑なシミュレーション

## よくあるミスと回避方法

### 1. 問題文の曖昧さ

**問題**: 「適切な値を返す」など曖昧な表現

**解決**: 具体的な条件を明記
- ❌ 「適切な値を返す」
- ✅ 「2つの数の和が `target` と等しくなる組み合わせが存在すれば `True`」

### 2. 制約条件の不足

**問題**: 入力の範囲が不明確

**解決**: すべての変数の範囲を明記
```markdown
## 制約条件

- `1 <= n <= 10^5`
- `-10^9 <= nums[i] <= 10^9`
```

### 3. サンプルの不足

**問題**: サンプルが1つだけ、または特殊ケースのみ

**解決**: 様々なパターンのサンプルを提示
- 基本ケース
- エッジケース
- 特殊なパターン

### 4. テストケースの不備

**問題**: 
- 期待値が間違っている
- テストケースが少なすぎる
- エッジケースが不足

**解決**: 
- 期待値を手計算で確認
- 様々なパターンをカバー
- 境界条件をテスト

### 5. 関数シグネチャの不一致

**問題**: 問題文と関数シグネチャが一致しない

**解決**: 
- 問題文の入力仕様と一致させる
- 型ヒントを正確に記述

### 6. JSONの構文エラー

**問題**: JSONの構文が正しくない

**解決**: 
- JSONバリデーターで確認
- エスケープ文字に注意（特にMarkdown内のコードブロック）
- 文字列内の改行は `\n` を使用

## 実例

### 例1: Easy問題（配列内の2数の和）

完全な例は `problems/ct-001.json` を参照してください。

**ポイント**:
- 明確な問題文
- 複数のサンプル（4個）
- 様々なエッジケース
- 適切な制約条件

### 例2: Hard問題（依存関係を持つタスクの最短完了時間）

完全な例は `problems/ct-003.json` を参照してください。

**ポイント**:
- 複雑な問題を段階的に説明
- 様々なパターンのサンプル（並列、直列、合流）
- 複雑なDAGのテストケース
- 適切な時間制限（2.0秒）

### 問題作成チェックリスト

問題を作成したら、以下を確認してください:

- [ ] 問題文が明確で完全か
- [ ] 入力仕様が明確か
- [ ] 出力仕様が明確か
- [ ] 制約条件がすべて記載されているか
- [ ] サンプルが十分か（最低3-4個）
- [ ] 関数シグネチャが正しいか
- [ ] テストケースが十分か（公開・非公開）
- [ ] エッジケースがカバーされているか
- [ ] 境界条件がテストされているか
- [ ] JSONの構文が正しいか
- [ ] 難易度が適切か
- [ ] カテゴリが適切か
- [ ] 時間制限が適切か

## 参考リソース

- `PROBLEM_FORMAT.md`: 基本的なフォーマット仕様
- `problems/ct-001.json`: Easy問題の例
- `problems/ct-003.json`: Hard問題の例
- `problem_definition/python_hard.md`: 問題定義のテンプレート

## トラブルシューティング

### JSONの構文エラー

```bash
# JSONの構文を確認
python -m json.tool problems/ct-XXX.json
```

### テストコードの実行確認

問題を作成したら、実際にテストコードが動作するか確認してください。

### 問題文の表示確認

Markdownが正しく表示されるか、実際のアプリケーションで確認してください。

